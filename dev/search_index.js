var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"K. G. Budden, “The numerical solution of differential equations governing reflexion of long radio waves from the ionosphere,” Proc. R. Soc. Lond. A, vol. 227, no. 1171, pp. 516–537, Feb. 1955, doi: 10.1098/rspa.1955.0027.\nK. G. Budden, “The influence of the earth’s magnetic field on radio propagation by wave-guide modes,” Proceedings of the Royal Society of London. Series A. Mathematical and Physical Sciences, vol. 265, no. 1323, pp. 538–553, Feb. 1962, doi: 10.1098/rspa.1962.0041.\nK. G. Budden, “The propagation of radio waves: the theory of radio waves of low power in the ionosphere and magnetosphere,” First paperback edition. New York: Cambridge University Press, 1988.\nP. C. Clemmow and J. Heading, “Coupled forms of the differential equations governing radio propagation in the ionosphere,” Mathematical Proceedings of the Cambridge Philosophical Society, vol. 50, no. 2, pp. 319–333, Apr. 1954, doi: 10.1017/S030500410002939X.\nJ. A. Ferguson and F. P. Snyder, “Approximate VLF/LF waveguide mode conversion model: Computer applications: FASTMC and BUMP,” Naval Ocean Systems Center, San Diego, CA, NOSC-TD-400, Nov. 1980. Accessed: May 08, 2017. Available: https://www.dtic.mil/docs/citations/ADA096240.\nD. G. Morfitt and C. H. Shellman, “‘MODESRCH’, an improved computer program for obtaining ELF/VLF/LF mode constants in an Earth-ionosphere waveguide,” Naval Electronics Laboratory Center, San Diego, CA, NELC/IR-77T, Oct. 1976. Accessed: Dec. 13, 2017. Available: https://www.dtic.mil/docs/citations/ADA032573.\nD. G. Morfitt, “‘Simplified’ VLF/LF mode conversion computer programs: GRNDMC and ARBNMC,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-514, Jan. 1980. Accessed: Jan. 15, 2018. Available: https://www.dtic.mil/docs/citations/ADA082695.\nR. A. Pappert, E. E. Gossard, and I. J. Rothmuller, “A numerical investigation of classical approximations used in VLF propagation,” Radio Science, vol. 2, no. 4, pp. 387–400, Apr. 1967, doi: 10.1002/rds196724387.\nR. A. Pappert and R. R. Smith, “Orthogonality of VLF height gains in the earth ionosphere waveguide,” Radio Science, vol. 7, no. 2, pp. 275–278, 1972, doi: 10.1029/RS007i002p00275.\nR. A. Pappert and L. R. Shockey, “Simplified VLF/LF mode conversion program with allowance for elevated, arbitrarily oriented electric dipole antennas,” Naval Electronics Laboratory Center, San Diego, CA, Interim Report 771, Oct. 1976. Accessed: Dec. 03, 2019. Available: https://archive.org/details/DTIC_ADA033412.\nR. A. Pappert, “LF daytime earth ionosphere waveguide calculations,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-647, Jan. 1981. Accessed: Jan. 23, 2020. Available: https://apps.dtic.mil/docs/citations/ADA096098.\nR. A. Pappert, L. R. Hitney, and J. A. Ferguson, “ELF/VLF (Extremely Low Frequency/Very Low Frequency) long path pulse program for antennas of arbitrary elevation and orientation,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-891, Aug. 1983. Accessed: Jul. 04, 2018. Available: https://www.dtic.mil/docs/citations/ADA133876.\nR. A. Pappert and J. A. Ferguson, “VLF/LF mode conversion model calculations for air to air transmissions in the earth-ionosphere waveguide,” Radio Sci., vol. 21, no. 4, pp. 551–558, Jul. 1986, doi: 10.1029/RS021i004p00551.\nM. L. V. Pitteway, “The numerical calculation of wave-fields, reflexion coefficients and polarizations for long radio waves in the lower ionosphere. I.,” Phil. Trans. R. Soc. Lond. A, vol. 257, no. 1079, pp. 219–241, Mar. 1965, doi: 10.1098/rsta.1965.0004.\nJ. A. Ratcliffe, \"The magneto-ionic theory & its applications to the ionosphere,\" Cambridge University Press, 1959.\nN. R. Thomson, “Experimental daytime VLF ionospheric parameters,” Journal of Atmospheric and Terrestrial Physics, vol. 55, no. 2, pp. 173–184, Feb. 1993, doi: 10.1016/0021-9169(93)90122-F.\nJ. R. Wait and K. P. Spies, “Characteristics of the earth-ionosphere waveguide for VLF radio waves,” U.S. National Bureau of Standards, Boulder, CO, Technical Note 300, Dec. 1964. Accessed: Feb. 18, 2017. Available: https://archive.org/details/characteristicso300wait.","category":"page"},{"location":"lib/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Documentation of all consts, structs, functions, etc.","category":"page"},{"location":"lib/internals/","page":"Internals","title":"Internals","text":"Modules = [LongwaveModePropagator, LongwaveModePropagator.Fields]\nPublic = false\nPages = [\n  \"Antennas.jl\",\n  \"bookerquartic.jl\",\n  \"EigenAngles.jl\",\n  \"Emitters.jl\",\n  \"Geophysics.jl\",\n  \"IO.jl\",\n  \"LongwaveModePropagator.jl\",\n  \"magnetoionic.jl\",\n  \"modeconversion.jl\",\n  \"modefinder.jl\",\n  \"modesum.jl\",\n  \"Samplers.jl\",\n  \"TMatrix.jl\",\n  \"utils.jl\",\n  \"Wavefields.jl\",\n  \"Waveguides.jl\"\n]","category":"page"},{"location":"lib/internals/#LongwaveModePropagator.AbstractDipole","page":"Internals","title":"LongwaveModePropagator.AbstractDipole","text":"AbstractDipole <: Antenna\n\nAbstract type for dipole antennas.\n\nSubtypes of AbstractDipole have an orientation azimuth_angle (ϕ) and inclination_angle (γ) where\n\n[rad] ϕ γ\n0 end fire vertical\nπ/2 broadside horizontal\n\nnote: Note\nAngles describe the orientation of the antenna, not the radiation pattern.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.Antenna","page":"Internals","title":"LongwaveModePropagator.Antenna","text":"Antenna\n\nAbstract supertype for all antenna-like types. \n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.bookerquartic","page":"Internals","title":"LongwaveModePropagator.bookerquartic","text":"bookerquartic(ea::EigenAngle, M)\nbookerquartic(T::TMatrix)\n\nCompute roots q and the coefficients B of the Booker quartic described by the susceptibility tensor M or T matrix.\n\nReferences\n\n[Budden1988]: K. G. Budden, “The propagation of radio waves: the theory of radio     waves of low power in the ionosphere and magnetosphere,” First paperback edition.     New York: Cambridge University Press, 1988.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.bookerreflection","page":"Internals","title":"LongwaveModePropagator.bookerreflection","text":"bookerreflection(ea::EigenAngle, M::SMatrix{3,3})\nbookerreflection(ea::EigenAngle, e)\n\nCompute the ionosphere reflection coefficient matrix for a sharply bounded ionosphere from 4×2 wavefields matrix e or the susceptibility matrix M.\n\nThe ionosphere reflection coefficient matrix is computed from a ratio of the downgoing to upgoing plane waves in the free space beneath the ionosphere [Budden1988] pg. 307. These are obtained from the two upgoing characteristic waves found from the Booker quartic. Each make up a column of e.\n\nR =\n    beginpmatrix\n        Ce₁4 - e₁1   Ce₂4 - e₂1 \n       -Ce₁2 + e₁3  -Ce₂2 + e₂3\n    endpmatrix\n    beginpmatrix\n        Ce₁4 + e₁1   Ce₂4 + e₂1 \n       -Ce₁2 - e₁3  -Ce₂2 - e₂3\n    endpmatrix^-1\n\nThe reflection coefficient matrix for the sharply bounded case is commonly used as a starting solution for integration of the reflection coefficient matrix through the ionosphere.\n\nReferences\n\n[Budden1988]: K. G. Budden, “The propagation of radio waves: the theory of radio     waves of low power in the ionosphere and magnetosphere,” First paperback edition.     New York: Cambridge University Press, 1988.\n\nExtended help\n\nThe set of horizontal field components e = (Ex -Ey Z₀Hx Z₀Hy)ᵀ can be separated into an upgoing and downgoing wave, each of which is generally elliptically polarized. A ratio of the amplitudes of these two waves give a reflection coefficient, except it would only apply for an incident wave of that particular elliptical polarization. However, the first set of fields can be linearly combined with a second independent solution for the fields, which will generally have a elliptical polarization than the first. Two linear combinations of the two sets of fields are formed with unit amplitude, linearly polarized incident waves. The reflected waves then give the components R₁₁, R₂₁ or R₁₂, R₂₂ for the incident wave in the plane of incidence and perpendicular to it, respectively [Budden1988] pg 552.\n\nThe process for determining the reflection coefficient requires resolving the two sets of fields e₁ and e₂ into the four linearly polarized vacuum modes. The layer of vacuum can be assumed to be so thin that it does not affect the fields. There will be two upgoing waves and two downgoing waves, each which has one E and one H in the plane of incidence. If f₁ f₂ f₃ f₄ are the complex amplitudes of the four component waves, then in matrix notation e = Lf where L is the appropriate transformation matrix.\n\nFor e₁ and e₂, we can find the corresponding vectors f1 and f2 by f1 = L¹e₁, f2 = L¹e₂ where the two column vectors are partitioned such that f1 = (u1 d1)ᵀ and f2 = (u2 d2)ᵀ for upgoing and downgoing 2-element vectors u and d. From the definition of the reflection coefficient R, d = Ru. Letting U = (u1 u2), D = (d1 d2), then D = RU and the reflection coefficient is R = DU¹. Because the reflection coefficient matrix is a ratio of fields, either e₁ and/or e₂ can be independently multiplied by an arbitrary constant and the value of R is unaffected.\n\nThis function directly computes D and U and solves for R using the right division operator R = D/U.\n\nFor additional details, see [Budden1988], chapter 18, section 7.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.bookerreflection-Tuple{EigenAngle,Any,LongwaveModePropagator.Dθ}","page":"Internals","title":"LongwaveModePropagator.bookerreflection","text":"bookerreflection(ea::EigenAngle, M, ::Dθ)\n\nCompute the ionosphere reflection coefficient matrix R for a sharply bounded ionosphere with susceptibility tensor M, as well as its derivative dRdθ returned as the tuple (R, dR).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.bookerwavefields","page":"Internals","title":"LongwaveModePropagator.bookerwavefields","text":"bookerwavefields(ea::EigenAngle, M)\nbookerwavefields(T::TMatrix)\n\nCompute the two-column wavefields matrix e from the ionosphere with susceptibility tensor M or T matrix for the two upgoing wavefields.\n\nThe first column of e is the evanescent wave and the second is the travelling wave.\n\ne =\n    beginpmatrix\n         Ex₁    Ex₂ \n        -Ey₁   -Ey₂ \n         Hx₁    Hx₂ \n         Hy₁    Hy₂\n    endpmatrix\n\nThis function solves the eigenvalue problem Te = qe. First, the Booker quartic is solved for the roots q. Then they are sorted so that the roots associated with the two upgoing waves can be selected. e is solved as the eigenvectors for the two qs. An analytical solution is used where e[2,:] = 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.bookerwavefields-Tuple{LongwaveModePropagator.TMatrix,Any,LongwaveModePropagator.Dθ}","page":"Internals","title":"LongwaveModePropagator.bookerwavefields","text":"bookerwavefields(ea::EigenAngle, M, ::Dθ)\nbookerwavefields(T::TMatrix, dT, ::Dθ)\n\nCompute the two-column wavefields matrix e as well as its derivative with respect to θ, returned as a tuple (e, de) for the ionosphere with susceptibility tensor M or T matrix and its derivative with respect to θ, dT.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dbookerquartic","page":"Internals","title":"LongwaveModePropagator.dbookerquartic","text":"dbookerquartic(ea::EigenAngle, M, q, B)\ndbookerquartic(T::TMatrix, dT, q, B)\n\nCompute derivative dq of the Booker quartic roots q with respect to θ for the ionosphere described by susceptibility tensor M or T matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.sortquarticroots!-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.sortquarticroots!","text":"sortquarticroots!(q)\n\nSort array of quartic roots q in place such that the first two correspond to upgoing waves and the latter two correspond to downgoing waves.\n\nGeneral locations of the four roots of the Booker quartic on the complex plane corresponding to the:\n\n1) upgoing evanescent wave\n2) upgoing travelling wave\n3) downgoing evanescent wave\n4) downgoing travelling wave\n\n          Im\n      3 . |\n          |\n          |\n  . 4     |\n ------------------Re\n          |      . 2\n          |\n          |\n          | . 1\n\nBased on [Pitteway1965] fig. 5.\n\nReferences\n\n[Pitteway1965]: M. L. V. Pitteway, “The numerical calculation of wave-fields, reflexion     coefficients and polarizations for long radio waves in the lower ionosphere. I.,” Phil.     Trans. R. Soc. Lond. A, vol. 257, no. 1079, pp. 219–241, Mar. 1965,     doi: 10.1098/rsta.1965.0004.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.upgoing-Tuple{Complex}","page":"Internals","title":"LongwaveModePropagator.upgoing","text":"upgoing(q)\n\nCalculate the absolute angle of q in radians from 315°×π/180 on the complex plane. Smaller values indicate upgoing waves.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Base.isless-Tuple{EigenAngle,EigenAngle}","page":"Internals","title":"Base.isless","text":"isless(x::EigenAngle, y::EigenAngle)\n\nCalls Base.isless for complex EigenAngle by real and then imag component.\n\nBy defining isless, calling sort on EigenAngles sorts by real component first and imaginary component second.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.isdetached-Tuple{EigenAngle,Frequency}","page":"Internals","title":"LongwaveModePropagator.isdetached","text":"isdetached(ea::EigenAngle, frequency::Frequency; params=LMPParams())\n\nReturn true if this is likely an earth detached (whispering gallery) mode according to the criteria in [Pappert1981] eq. 1 with the additional criteria that the frequency be above 100 kHz.\n\nReferences\n\n[Pappert1981]: R. A. Pappert, “LF daytime earth ionosphere waveguide calculations,” Naval     Ocean Systems Center, San Diego, CA, NOSC/TR-647, Jan. 1981.     [Online]. Available: https://apps.dtic.mil/docs/citations/ADA096098.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.AirborneTransmitter","page":"Internals","title":"LongwaveModePropagator.AirborneTransmitter","text":"AirborneTransmitter{A<:Antenna} <: Emitter\n\nSimilar to Transmitter except it also contains an altitude field in meters.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.Emitter","page":"Internals","title":"LongwaveModePropagator.Emitter","text":"Emitter\n\nAbstract type for types that energize the waveguide with electromagnetic energy.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.dip-Tuple{BField}","page":"Internals","title":"LongwaveModePropagator.dip","text":"dip(b::BField)\n\nReturn the dip angle in radians from b.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.gyrofrequency-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.gyrofrequency","text":"gyrofrequency(q, m, B)\ngyrofrequency(s::Species, b::BField)\n\nReturn the signed gyrofrequency Ω = qBm.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.magnetoionicparameters-Tuple{Any,Frequency,BField,Species}","page":"Internals","title":"LongwaveModePropagator.magnetoionicparameters","text":"magnetoionicparameters(z, frequency::Frequency, species::Species, bfield::BField)\n\nCompute the magnetoionic parameters X, Y, and Z for height z.\n\nX = N e²  (ϵ₀ m ω²)\nY = e B  (m ω)\nZ = ν  ω\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.plasmafrequency-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.plasmafrequency","text":"plasmafrequency(n, q, m)\nplasmafrequency(z, s::Species)\n\nReturn the plasma frequency ωₚ = (nq²(ϵ₀m)) for a ``cold'' plasma.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.waitsparameter-Tuple{Any,Frequency,BField,Species}","page":"Internals","title":"LongwaveModePropagator.waitsparameter","text":"waitsparameter(z, frequency::Frequency, bfield::BField, species::Species)\n\nCompute Wait's conductivity parameter Wr.\n\nωᵣ = Xω²ν = ωₚ²ν\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.Input","page":"Internals","title":"LongwaveModePropagator.Input","text":"Input\n\nAbstract supertype for structs carrying information to be input to the model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.Output","page":"Internals","title":"LongwaveModePropagator.Output","text":"Output\n\nAbstract supertype for structs containing information to be output from the model.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.buildrun","page":"Internals","title":"LongwaveModePropagator.buildrun","text":"buildrun(s::BasicInput; mesh=nothing, unwrap=true, params=LMPParams())\nbuildrun(s::TableInput; mesh=nothing, unwrap=true, params=LMPParams())\nbuildrun(s::BatchInput; mesh=nothing, unwrap=true, params=LMPParams())\n\nBuild LMP structs from an Input and run LMP.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.buildrunsave-Tuple{Any,BatchInput}","page":"Internals","title":"LongwaveModePropagator.buildrunsave","text":"buildrunsave(outfile, s::BatchInput; append=false, mesh=nothing, unwrap=true, params=LMPParams())\n\nSimilar to buildrun, except it saves results into outfile as s is processed.\n\nIf append=true, this function parses outfile for preexisting results and only runs the remaining scenarios in s. Otherwise, a new BatchOutput is created.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.buildwaveguide-Tuple{BasicInput,Any}","page":"Internals","title":"LongwaveModePropagator.buildwaveguide","text":"buildwaveguide(s::BasicInput, i)\n\nReturn HomogeneousWaveguide from the ith entry in each field of s.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.buildwaveguide-Tuple{TableInput,Any}","page":"Internals","title":"LongwaveModePropagator.buildwaveguide","text":"buildwaveguide(s::TableInput, i)\n\nReturn HomogeneousWaveguide from the ith entry in each field of s with a linear interpolation over density and collision_frequency.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.iscomplete-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.iscomplete","text":"iscomplete(s)\n\nReturn true if input or output struct s is completely defined, otherwise return false.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.parse-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.parse","text":"parse(file)\n\nParse a JSON file compatible with Input or Output types.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.validlengths","page":"Internals","title":"LongwaveModePropagator.validlengths","text":"validlengths(s)\n\nCheck if field lengths of input s match their number of segments.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.BOTTOMHEIGHT","page":"Internals","title":"LongwaveModePropagator.BOTTOMHEIGHT","text":"Bottom of reflection coefficient integration. LongwaveModePropagator.jl assumes BOTTOMHEIGHT = 0.0.\n\n\n\n\n\n","category":"constant"},{"location":"lib/internals/#LongwaveModePropagator.Dθ","page":"Internals","title":"LongwaveModePropagator.Dθ","text":"Indicates derivative with respect to eigenangle θ.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.ModeEquation","page":"Internals","title":"LongwaveModePropagator.ModeEquation","text":"ModeEquation\n\nFunctions can dispatch on subtypes of ModeEquation, although currently only PhysicalModeEquation is supported.\n\nFuture work might include the ModifiedModeEquation of [Morfitt1976].\n\nReferences\n\n[Morfitt1976]: D. G. Morfitt and C. H. Shellman, “‘MODESRCH’, an improved computer program     for obtaining ELF/VLF/LF mode constants in an Earth-ionosphere waveguide,” Naval     Electronics Laboratory Center, San Diego, CA, NELC/IR-77T, Oct. 1976. [Online].     Available: http://www.dtic.mil/docs/citations/ADA032573.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.susceptibility","page":"Internals","title":"LongwaveModePropagator.susceptibility","text":"susceptibility(altitude, frequency, bfield, species; params=LMPParams())\nsusceptibility(altitude, frequency, w::HomogeneousWaveguide; params=LMPParams())\nsusceptibility(altitude, me::ModeEquation; params=LMPParams())\n\nCompute the ionosphere susceptibility tensor M as a SMatrix{3,3} using species.numberdensity and species.collisionfrequency at altitude.\n\nIf params.earthcurvature == true, M includes a first order correction for earth curvature by means of a fictitious refractive index [Pappert1967].\n\nThe susceptibility matrix is calculated from the constitutive relations presented in [Ratcliffe1959]. This includes the effect of earth's magnetic field vector and collisional damping on electron motion.\n\nThe tensor is:\n\nM = -fracXU(U²-Y²)\n        beginpmatrix\n            U² - x²Y²     -izUY - xyY²  iyUY - xzY² \n            izUY - xyY²   U² - y²Y²     -ixUY - yzY² \n            -iyUY - xzY²  ixUY - yzY²   U² - z²Y²\n        endpmatrix\n\nwhere X = ωₚ²ω², Y = ωₕω, Z = νω, and U = 1 - iZ. The earth curvature correction subtracts 2Rₑ*(H - altitude) from the diagonal of M where H is params.curvatureheight.\n\nReferences\n\n[Pappert1967]: R. A. Pappert, E. E. Gossard, and I. J. Rothmuller, “A numerical     investigation of classical approximations used in VLF propagation,” Radio Science,     vol. 2, no. 4, pp. 387–400, Apr. 1967, doi: 10.1002/rds196724387.\n\n[Ratcliffe1959]: J. A. Ratcliffe, \"The magneto-ionic theory & its applications to the     ionosphere,\" Cambridge University Press, 1959.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.modeconversion-Union{Tuple{H}, Tuple{LongwaveModePropagator.Wavefields{H},LongwaveModePropagator.Wavefields{H},LongwaveModePropagator.Wavefields{H}}} where H","page":"Internals","title":"LongwaveModePropagator.modeconversion","text":"modeconversion(previous_wavefields::Wavefields, wavefields::Wavefields,\n    adjoint_wavefields::Wavefields; params=LMPParams())\n\nCompute the mode conversion matrix a from the modes associated with previous_wavefields to modes associated with wavefields and its adjoint_wavefields.\n\nThis is used in the approach known as full mode conversion [Pappert1972b].\n\nReferences\n\n[Pappert1972b]: R. A. Pappert and R. R. Smith, “Orthogonality of VLF height gains in the     earth ionosphere waveguide,” Radio Science, vol. 7, no. 2, pp. 275–278, 1972,     doi: 10.1029/RS007i002p00275.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dRdz-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.dRdz","text":"dRdz(R, p, z)\n\nCompute the differential of the reflection matrix R, dRdz, at height z. p is a tuple containing instances (PhysicalModeEquation(), LMPParams()).\n\nFollowing the Budden formalism for the reflection of an (obliquely) incident plane wave from a horizontally stratified ionosphere [Budden1955a], the differential of the reflection matrix R with height z can be described by\n\ndRdz = k(2i)(W₂₁ + W₂₂R - RW₁₁ - RW₁₂R)\n\nIntegrating dRdz downwards through the ionosphere gives the reflection matrix R for the ionosphere as if it were a sharp boundary at the stopping level with free space below.\n\nReferences\n\n[Budden1955a]: K. G. Budden, “The numerical solution of differential equations governing     reflexion of long radio waves from the ionosphere,” Proc. R. Soc. Lond. A, vol. 227,     no. 1171, pp. 516–537, Feb. 1955.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dRdθdz-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.dRdθdz","text":"dRdθdz(RdRdθ, p, z)\n\nCompute the differential dRdθdz at height z returned as an SMatrix{4,2} with dRdz in the first 2 rows and dRdθdz in the bottom 2 rows.\n\np is a tuple containing instances (PhysicalModeEquation(), LMPParams()).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.defaultmesh-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.defaultmesh","text":"defaultmesh(frequency; rmin=deg2rad(30.0), imin=deg2rad(-10.0),\n    Δr_coarse=deg2rad(0.5), Δr_fine=deg2rad(0.15),\n    rtransition=deg2rad(75.0), itransition=deg2rad(-1.5))\n\nGenerate vector of complex coordinates to be used by GRPF in the search for waveguide modes.\n\nrmin is the lower bound of the real axis and imin is the lower bound of the imaginary axis.\n\nAt frequencies above 12 kHz the mesh spacing in the upper right corner of the domain with real values above rtransition and imaginary values above itransition is Δr_fine and is Δr_coarse everywhere else.\n\nAt frequencies below 12 kHz the mesh spacing is always Δr_coarse.\n\nThe lower right diagonal of the lower right quadrant of the complex plane is excluded from the mesh.\n\nSee also: findmodes\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dmodalequation-NTuple{4,Any}","page":"Internals","title":"LongwaveModePropagator.dmodalequation","text":"dmodalequation(R, dR, Rg, dRg)\n\nCompute the derivative of the determinantal mode equation with respect to θ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dwmatrix-Tuple{EigenAngle,Any,Any}","page":"Internals","title":"LongwaveModePropagator.dwmatrix","text":"dwmatrix(ea::EigenAngle, T, dT)\n\nCompute the four submatrix elements of dWdθ returned as the tuple (dW₁₁, dW₂₁, dW₁₂, dW₂₂) from the ionosphere with T matrix and its derivative with respect to θ, dT.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.filterroots!","page":"Internals","title":"LongwaveModePropagator.filterroots!","text":"filterroots!(roots, frequency, waveguide; atol=0.1)\nfilterroots!(roots, modeequation; atol=0.1)\n\nRemove elements from roots if they are not valid roots of the physical modal equation.\n\nAlthough the default atol for this function is larger than for isroot(@ref), the modal equation is very sensitive to θ, and thus is much larger than 0.1 if θ is off from an eigenangle even slightly.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.fresnelreflection","page":"Internals","title":"LongwaveModePropagator.fresnelreflection","text":"fresnelreflection(ea::EigenAngle, ground::Ground, frequency::Frequency)\nfresnelreflection(m::PhysicalModeEquation)\n\nCompute the Fresnel reflection coefficient matrix for the ground-freespace interface at the ground.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.fresnelreflection-Tuple{EigenAngle,Ground,Frequency,LongwaveModePropagator.Dθ}","page":"Internals","title":"LongwaveModePropagator.fresnelreflection","text":"fresnelreflection(ea::EigenAngle, ground::Ground, frequency::Frequency, ::Dθ)\nfresnelreflection(m::PhysicalModeEquation, ::Dθ)\n\nCompute the Fresnel reflection coefficient matrix for the ground as well as its derivative with respect to θ returned as the tuple (Rg, dRg).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.integratedreflection-Tuple{PhysicalModeEquation,LongwaveModePropagator.Dθ}","page":"Internals","title":"LongwaveModePropagator.integratedreflection","text":"integratedreflection(modeequation::PhysicalModeEquation, ::Dθ; params=LMPParams())\n\nCompute R and dRdθ as an SMatrix{4,2} with R in rows (1, 2) and dRdθ in rows (3, 4).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.integratedreflection-Tuple{PhysicalModeEquation}","page":"Internals","title":"LongwaveModePropagator.integratedreflection","text":"integratedreflection(modeequation::PhysicalModeEquation; params=LMPParams())\n\nIntegrate dRdz downward through the ionosphere described by modeequation from params.topheight, returning the ionosphere reflection coefficient R at the ground.\n\nparams.integrationparams are passed to DifferentialEquations.jl.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.isroot-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.isroot","text":"isroot(x; atol=1e-2)\n\nReturn true if x is approximately equal to 0 with the absolute tolerance atol.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.modalequation-Tuple{Any,Any}","page":"Internals","title":"LongwaveModePropagator.modalequation","text":"modalequation(R, Rg)\n\nCompute the determinental mode equation det(Rg R - I) given reflection coefficients R and Rg.\n\nA propagating waveguide mode requires that a wave, having reflected from the ionosphere and then the ground, must be identical with the original upgoing wave. This criteria is met at roots of the mode equation [Budden1962].\n\nReferences\n\n[Budden1962]: K. G. Budden and N. F. Mott, “The influence of the earth’s magnetic field on     radio propagation by wave-guide modes,” Proceedings of the Royal Society of London.     Series A. Mathematical and Physical Sciences, vol. 265, no. 1323, pp. 538–553,     Feb. 1962.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.solvedmodalequation-Tuple{Any,PhysicalModeEquation}","page":"Internals","title":"LongwaveModePropagator.solvedmodalequation","text":"solvedmodalequation(θ, modeequation::PhysicalModeEquation; params=LMPParams())\n\nSet θ for modeequation and then solve the derivative of the mode equation with respect to θ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.solvedmodalequation-Tuple{PhysicalModeEquation}","page":"Internals","title":"LongwaveModePropagator.solvedmodalequation","text":"solvedmodalequation(modeequation::PhysicalModeEquation; params=LMPParams())\n\nCompute the derivative of the modal equation with respect to θ returned as the tuple (dF, R, Rg) for the ionosphere and ground reflection coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.solvemodalequation-Tuple{Any,PhysicalModeEquation}","page":"Internals","title":"LongwaveModePropagator.solvemodalequation","text":"solvemodalequation(θ, modeequation::PhysicalModeEquation; params=LMPParams())\n\nSet θ for modeequation and then solve the modal equation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.solvemodalequation-Tuple{PhysicalModeEquation}","page":"Internals","title":"LongwaveModePropagator.solvemodalequation","text":"solvemodalequation(modeequation::PhysicalModeEquation; params=LMPParams())\n\nCompute the ionosphere and ground reflection coefficients and return the value of the determinental modal equation associated with modeequation.\n\nSee also: solvedmodalequation\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.trianglemesh-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.trianglemesh","text":"trianglemesh(zbl, ztr, Δr)\n\nGenerate initial mesh node coordinates for a right triangle domain from complex coordinate zbl in the bottom left and ztr in the top right with initial mesh step Δr.\n\nzbl and ztr are located on the complex plane at the locations marked in the diagram below:\n\n       im\n       |\n-re ---|------ ztr\n       |     /\n       |    /\n       |   /\n       |  /\n       zbl\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.wmatrix-Tuple{EigenAngle,Any}","page":"Internals","title":"LongwaveModePropagator.wmatrix","text":"wmatrix(ea::EigenAngle, T)\n\nCompute the four submatrix elements of W used in the equation dRdz from the ionosphere with T matrix returned as a tuple (W₁₁, W₂₁, W₁₂, W₂₂).\n\nFollowing Budden's formalism for the reflection matrix of a plane wave obliquely incident on the ionosphere [Budden1955a], the wave below the ionosphere can be resolved into upgoing and downgoing waves of elliptical polarization, each of whose components are themselves resolved into a component with the electric field in the plane of propagation and a component perpendicular to the plane of propagation. The total field can be written in matrix form as e = Lf where L is a 4×4 matrix that simply selects and specifies the incident angle of the components and f is a column matrix of the complex amplitudes of the component waves. By inversion, f = L¹e and its derivative with respect to height z is f = -iL¹TLf = -½iWf. Then W = 2L¹TL describes the change in amplitude of the upgoing and downgoing component waves.\n\nW is also known as S in many texts.\n\nReferences\n\n[Budden1955a]: K. G. Budden, “The numerical solution of differential equations governing     reflexion of long radio waves from the ionosphere,” Proc. R. Soc. Lond. A, vol. 227,     no. 1171, pp. 516–537, Feb. 1955.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.ExcitationFactor","page":"Internals","title":"LongwaveModePropagator.ExcitationFactor","text":"ExcitationFactor{T,T2}\n\nConstants used in calculating excitation factors and height gains.\n\nFields\n\nF₁::T: height gain constant. See [Pappert1976].\nF₂::T\nF₃::T\nF₄::T\nh₁0::T: first modified Hankel function of order 1/3 at the ground.\nh₂0::T: second modified Hankel function of order 1/3 at the ground.\nEyHy::T: polarization ratio EyHy, derived from reflection coefficients (or Ts).\nRg::T2: ground reflection coefficient matrix.\n\nReferences\n\n[Pappert1976]: R. A. Pappert and L. R. Shockey, “Simplified VLF/LF mode conversion program     with allowance for elevated, arbitrarily oriented electric dipole antennas,” Naval     Electronics Laboratory Center, San Diego, CA, Interim Report 771, Oct. 1976. [Online].     Available: http://archive.org/details/DTIC_ADA033412.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.Efield-Tuple{Any,HomogeneousWaveguide,LongwaveModePropagator.Emitter,LongwaveModePropagator.AbstractSampler}","page":"Internals","title":"LongwaveModePropagator.Efield","text":"Efield(modes, waveguide::HomogeneousWaveguide, tx::Emitter, rx::AbstractSampler;\n       params=LMPParams())\n\nCompute the complex electric field by summing modes in waveguide for emitter tx at sampler rx.\n\nReferences\n\n[Morfitt1980]: D. G. Morfitt, “‘Simplified’ VLF/LF mode conversion computer programs:     GRNDMC and ARBNMC,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-514, Jan. 1980.     [Online]. Available: http://www.dtic.mil/docs/citations/ADA082695.\n\n[Pappert1983]: R. A. Pappert, L. R. Hitney, and J. A. Ferguson, “ELF/VLF (Extremely Low     Frequency/Very Low Frequency) long path pulse program for antennas of arbitrary     elevation and orientation,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-891,     Aug. 1983. [Online]. Available: http://www.dtic.mil/docs/citations/ADA133876.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.Efield-Tuple{SegmentedWaveguide,Any,Any,LongwaveModePropagator.Emitter,LongwaveModePropagator.AbstractSampler}","page":"Internals","title":"LongwaveModePropagator.Efield","text":"Efield(waveguide::SegmentedWaveguide, wavefields_vec, adjwavefields_vec, tx::Emitter,\n       rx::AbstractSampler; params=LMPParams())\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.excitationfactor-Tuple{Any,Any,Any,LongwaveModePropagator.ExcitationFactor}","page":"Internals","title":"LongwaveModePropagator.excitationfactor","text":"excitationfactor(ea, dFdθ, R, Rg, efconstants::ExcitationFactor; params=LMPParams())\n\nCompute excitation factors for the Hy field at the emitter returned as the tuple (λv, λb, λe) for vertical, broadside, and end-on dipoles. dFdθ is the derivative of the modal equation with respect to θ.\n\nThe excitation factor describes how efficiently the field component can be excited in the waveguide.\n\nThis function most closely follows the approach taken in [Pappert1983], which makes use of T (different from TMatrix) rather than τ. From the total Hy excitation factor (the sum product of the λs with the antenna orientation terms), the excitation factor for electric fields can be found as:\n\nλz = -S₀λ\nλx = EyHyλ\nλy = -λ\n\nnote: Note\nThis function assumes that reflection coefficients R and Rg are referenced to d = z = 0.\n\nReferences\n\n[Morfitt1980]: D. G. Morfitt, “‘Simplified’ VLF/LF mode conversion computer programs:     GRNDMC and ARBNMC,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-514, Jan. 1980.     [Online]. Available: http://www.dtic.mil/docs/citations/ADA082695.\n\n[Pappert1983]: R. A. Pappert, L. R. Hitney, and J. A. Ferguson, “ELF/VLF (Extremely Low     Frequency/Very Low Frequency) long path pulse program for antennas of arbitrary     elevation and orientation,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-891,     Aug. 1983. [Online]. Available: http://www.dtic.mil/docs/citations/ADA133876.\n\n[Pappert1986]: R. A. Pappert and J. A. Ferguson, “VLF/LF mode conversion model calculations     for air to air transmissions in the earth-ionosphere waveguide,” Radio Sci., vol. 21,     no. 4, pp. 551–558, Jul. 1986, doi: 10.1029/RS021i004p00551.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.excitationfactorconstants-NTuple{5,Any}","page":"Internals","title":"LongwaveModePropagator.excitationfactorconstants","text":"excitationfactorconstants(ea₀, R, Rg, frequency, ground; params=LMPParams())\n\nReturn an ExcitationFactor struct used in calculating height-gain functions and excitation factors where eigenangle ea₀ is referenced to the ground.\n\nnote: Note\nThis function assumes that reflection coefficients R and Rg are referenced to d = z = 0.\n\nReferences\n\n[Pappert1976]: R. A. Pappert and L. R. Shockey, “Simplified VLF/LF mode conversion program     with allowance for elevated, arbitrarily oriented electric dipole antennas,” Naval     Electronics Laboratory Center, San Diego, CA, Interim Report 771, Oct. 1976. [Online].     Available: http://archive.org/details/DTIC_ADA033412.\n\n[Ferguson1980]: J. A. Ferguson and F. P. Snyder, “Approximate VLF/LF waveguide mode     conversion model: Computer applications: FASTMC and BUMP,” Naval Ocean Systems Center,     San Diego, CA, NOSC-TD-400, Nov. 1980. [Online].     Available: http://www.dtic.mil/docs/citations/ADA096240.\n\n[Morfitt1980]: D. G. Morfitt, “‘Simplified’ VLF/LF mode conversion computer programs:     GRNDMC and ARBNMC,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-514, Jan. 1980.     [Online]. Available: http://www.dtic.mil/docs/citations/ADA082695.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.heightgains-Tuple{Any,Any,Any,LongwaveModePropagator.ExcitationFactor}","page":"Internals","title":"LongwaveModePropagator.heightgains","text":"heightgains(z, ea₀, frequency, efconstants::ExcitationFactor; params=LMPParams())\n\nCompute height gain functions at height z returned as the tuple (fz, fy, fx) where eigenangle ea₀ is referenced to the ground.\n\nfz is the height gain for the vertical electric field component Ez.\nfy is the height gain for the transverse electric field component Ey.\nfx is the height gain for the horizontal electric field component Ex.\n\n[Pappert1983]\n\nnote: Note\nThis function assumes that reflection coefficients are referenced to d = z = 0.\n\nSee also: excitationfactorconstants\n\nReferences\n\n[Pappert1983]: R. A. Pappert, L. R. Hitney, and J. A. Ferguson, “ELF/VLF (Extremely Low     Frequency/Very Low Frequency) long path pulse program for antennas of arbitrary     elevation and orientation,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-891,     Aug. 1983. [Online]. Available: http://www.dtic.mil/docs/citations/ADA133876.\n\n[Pappert1986]: R. A. Pappert and J. A. Ferguson, “VLF/LF mode conversion model calculations     for air to air transmissions in the earth-ionosphere waveguide,” Radio Sci., vol. 21,     no. 4, pp. 551–558, Jul. 1986, doi: 10.1029/RS021i004p00551.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.modeterms-Tuple{Any,LongwaveModePropagator.Emitter,LongwaveModePropagator.AbstractSampler}","page":"Internals","title":"LongwaveModePropagator.modeterms","text":"modeterms(modeequation, tx::Emitter, rx::AbstractSampler; params=LMPParams())\n\nCompute tx and rx height-gain and excitation factor products and ExcitationFactor constants returned as the tuple (txterm, rxterm).\n\nThe returned txterm is:\n\nλ_v cos(γ) f_z(zₜ) + λ_b sin(γ)sin(ϕ) f_y(zₜ) + λ_e sin(γ)cos(ϕ) f_z(zₜ)\n\nand rxterm is the height-gain function f(zᵣ) appropriate for rx.fieldcomponent:\n\nfieldcomponent f(zᵣ)\nz -S₀f_z\ny EyHyf_y\nx -f_x\n\nReferences\n\n[Pappert1976]: R. A. Pappert and L. R. Shockey, “Simplified VLF/LF mode conversion program     with allowance for elevated, arbitrarily oriented electric dipole antennas,” Naval     Electronics Laboratory Center, San Diego, CA, Interim Report 771, Oct. 1976. [Online].     Available: http://archive.org/details/DTIC_ADA033412.\n\n[Morfitt1980]: D. G. Morfitt, “‘Simplified’ VLF/LF mode conversion computer programs:     GRNDMC and ARBNMC,” Naval Ocean Systems Center, San Diego, CA, NOSC/TR-514, Jan. 1980.     [Online]. Available: http://www.dtic.mil/docs/citations/ADA082695.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.AbstractSampler","page":"Internals","title":"LongwaveModePropagator.AbstractSampler","text":"AbstractSampler\n\nAbstract supertype for sampling fields in the waveguide.\n\nSubtypes of AbstractSampler have a position in the guide and a Fields.Field.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.TMatrix","page":"Internals","title":"LongwaveModePropagator.TMatrix","text":"TMatrix <: SMatrix{4, 4, T}\n\nA custom SMatrix subtype that represents the T matrix from [Clemmow1954] that is semi-sparse. The form of the matrix is:\n\n┌                ┐\n| T₁₁ T₁₂ 0  T₁₄ |\n| 0   0   1  0   |\n| T₃₁ T₃₂ 0  T₃₄ |\n| T₄₁ T₄₂ 0  T₄₄ |\n└                ┘\n\nTMatrix implements efficient matrix-vector multiplication and other math based on its special form.\n\nSee also: tmatrix\n\nReferences\n\n[Clemmow1954]: P. C. Clemmow and J. Heading, “Coupled forms of the differential equations     governing radio propagation in the ionosphere,” Mathematical Proceedings of the     Cambridge Philosophical Society, vol. 50, no. 2, pp. 319–333, Apr. 1954.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.dtmatrix-Tuple{EigenAngle,Any}","page":"Internals","title":"LongwaveModePropagator.dtmatrix","text":"dtmatrix(ea::EigenAngle, M)\n\nCompute a dense SMatrix with the derivative of T with respect to θ.\n\nSee also: tmatrix\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.tmatrix-Tuple{EigenAngle,Any}","page":"Internals","title":"LongwaveModePropagator.tmatrix","text":"tmatrix(ea::EigenAngle, M)\n\nCompute the matrix T as a TMatrix for the differential equations of a wave propagating at angle ea in an ionosphere with susceptibility M.\n\nClemmow and Heading derived the T matrix from Maxwell's equations for an electromagnetic wave in the anisotropic, collisional cold plasma of the ionosphere in a coordinate frame where z is upward, propagation is directed obliquely in the x-z plane and invariance is assumed in y. For the four characteristic wave components e = (Ex -Ey Z₀Hx Z₀Hy)ᵀ, the differential equations are dedz = -ikTe.\n\nSee also: susceptibility, dtmatrix\n\nReferences\n\n[Budden1955a]: K. G. Budden, “The numerical solution of differential equations governing     reflexion of long radio waves from the ionosphere,” Proc. R. Soc. Lond. A, vol. 227,     no. 1171, pp. 516–537, Feb. 1955.\n\n[Clemmow1954]: P. C. Clemmow and J. Heading, “Coupled forms of the differential equations     governing radio propagation in the ionosphere,” Mathematical Proceedings of the     Cambridge Philosophical Society, vol. 50, no. 2, pp. 319–333, Apr. 1954.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.amplitude-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.amplitude","text":"amplitude(e)\n\nCompute field amplitude in dB.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.amplitudephase-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.amplitudephase","text":"amplitudephase(e)\n\nCompute field amplitude in dB and phase in radians and return as (amplitude, phase).\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.pow23","page":"Internals","title":"LongwaveModePropagator.pow23","text":"pow23(x)\n\nEfficiently compute x^(23).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.unwrap!","page":"Internals","title":"LongwaveModePropagator.unwrap!","text":"unwrap!(x)\n\nUnwrap a phase vector x in radians in-place.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.ScaleRecord","page":"Internals","title":"LongwaveModePropagator.ScaleRecord","text":"ScaleRecord\n\nStruct for saving wavefield scaling information used in a callback during Pitteway integration of wavefields [Pitteway1965].\n\nFields\n\nz::Float64: current height in meters.\ne::SMatrix{4,2,Complex{Float64},8}: wavefield matrix.\northo_scalar::Complex{Float64}: scalar for Gram-Schmidt orthogonalization.\ne1_scalar::Float64: scalar for wavefield vector 1.\ne2_scalar::Float64: scalar for wavefield vector 2.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.WavefieldIntegrationParams","page":"Internals","title":"LongwaveModePropagator.WavefieldIntegrationParams","text":"WavefieldIntegrationParams{F,G,T,T2,H}\n\nParameters passed to Pitteway integration of wavefields [Pitteway1965].\n\nFields\n\nz::Float64: height in meters.\nbottomz::Float64: bottom height of integration in meters.\northo_scalar::Complex{Float64}: scalar for Gram-Schmidt orthogonalization.\ne1_scalar::Float64: scalar for wavefield vector 1.\ne2_scalar::Float64: scalar for wavefield vector 2.\nea::EigenAngle: wavefield eigenangle.\nfrequency::Frequency: electromagentic wave frequency in Hz.\nbfield::BField: Earth's magnetic field in Tesla.\nspecies::Species{F,G}: species in the ionosphere.\nparams::LMPParams{T,T2,H}: module-wide parameters.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.WavefieldIntegrationParams-Union{Tuple{H}, Tuple{T2}, Tuple{T}, Tuple{G}, Tuple{F}, Tuple{Any,Any,Any,Any,Species{F,G},LMPParams{T,T2,H}}} where H where T2 where T where G where F","page":"Internals","title":"LongwaveModePropagator.WavefieldIntegrationParams","text":"WavefieldIntegrationParams(topheight, ea, frequency, bfield, species, params)\n\nInitialize a WavefieldIntegrationParams for downward Pitteway scaled integration [Pitteway1965].\n\nAutomatically set values are:\n\nbottomz = BOTTOMHEIGHT\northo_scalar = zero(ComplexF64)\ne1_scalar = one(Float64)\ne2_scalar = one(Float64)\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.Wavefields","page":"Internals","title":"LongwaveModePropagator.Wavefields","text":"Wavefields{H<:AbstractRange}\n\nStruct containing wavefield components for each mode of eas at heights.\n\nThe six electromagnetic field components are stored in the v field of the struct and accessed as a Matrix of SVector{6,ComplexF64} corresponding to [height, mode].\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.Wavefields-Tuple{Any,Array{EigenAngle,1}}","page":"Internals","title":"LongwaveModePropagator.Wavefields","text":"Wavefields(heights, eas::Vector{EigenAngle})\n\nA constructor for initializing Wavefields with an appropriately sized undef Matrix given eigenangles eas and heights.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#Base.:==-Tuple{LongwaveModePropagator.Wavefields,LongwaveModePropagator.Wavefields}","page":"Internals","title":"Base.:==","text":"==(A::Wavefields, B::Wavefields)\n\nCheck for equality == between A.v and B.v, heights, and eas.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.boundaryscalars","page":"Internals","title":"LongwaveModePropagator.boundaryscalars","text":"boundaryscalars(R, Rg, e1, e2, isotropic::Bool=false)\nboundaryscalars(R, Rg, e, isotropic::Bool=false)\n\nCompute coefficients (b1, b2) required to sum the two wavefields vectors e1 and e2 or both columns of e for the total wavefield at the ground as e = b1*e1 + b2*e2.\n\nThe b1 and b2 that satisfy the waveguide boundary conditions are only valid for true eigenangles of the waveguide.\n\nnote: Note\nThis function assumes that the reflection coefficients R and Rg and the wavefield vectors e1, e2 are at the ground.These boundary conditions\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.calculate_wavefields!-NTuple{5,Any}","page":"Internals","title":"LongwaveModePropagator.calculate_wavefields!","text":"calculate_wavefields!(wavefields, adjoint_wavefields, frequency, waveguide,\n    adjoint_waveguide; params=LMPParams())\n\nCompute fields of wavefields in-place scaled to satisfy the waveguide boundary conditions.\n\nThis function implements the method of integrating wavefields suggested by [Pitteway1965].\n\nReferences\n\n[Pitteway1965]: M. L. V. Pitteway, “The numerical calculation of wave-fields, reflexion     coefficients and polarizations for long radio waves in the lower ionosphere. I.,” Phil.     Trans. R. Soc. Lond. A, vol. 257, no. 1079, pp. 219–241, Mar. 1965,     doi: 10.1098/rsta.1965.0004.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dedz-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.dedz","text":"dedz(e, p, z)\n\nCompute derivative of field components vector e at height z.\n\nThe parameter p should be a WavefieldIntegrationParams.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.dedz-Tuple{Any,Any,LongwaveModePropagator.TMatrix}","page":"Internals","title":"LongwaveModePropagator.dedz","text":"dedz(e, k, T::Tmatrix)\n\nCompute dedz = -ikTe where e = (Ex -Ey Z₀Hx Z₀Hy)ᵀ.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.fieldstrengths!-Tuple{Any,Any,EigenAngle,Frequency,BField,Species,Ground}","page":"Internals","title":"LongwaveModePropagator.fieldstrengths!","text":"fieldstrengths!(EH, zs, me::ModeEquation; params=LMPParams())\nfieldstrengths!(EH, zs, ea::EigenAngle, frequency::Frequency, bfield::BField,\n    species::Species, ground::Ground; params=LMPParams())\n\nCompute (Ex Ey Ez Hx Hy Hz)ᵀ wavefields vectors as elements of EH by fullwave integration at each height in zs.\n\nThe wavefields are scaled to satisfy the waveguide boundary conditions, which is only valid at solutions of the mode equation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.fieldstrengths-Tuple{Any,LongwaveModePropagator.ModeEquation}","page":"Internals","title":"LongwaveModePropagator.fieldstrengths","text":"fieldstrengths(zs, me::ModeEquation; params=LMPParams())\n\nPreallocate vector of wavefields EH, then call fieldstrengths! and return EH.\n\nEach element of EH is an SVector of ex ey ez hx hy hz.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.integratewavefields-Tuple{Any,EigenAngle,Frequency,BField,Species}","page":"Internals","title":"LongwaveModePropagator.integratewavefields","text":"integratewavefields(zs, ea::EigenAngle, frequency::Frequency, bfield::BField,\n    species::Species; params=LMPParams())\n\nCompute wavefields vectors e at zs by downward integration over heights zs.\n\nparams.integrationparams is not used by this function.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.savevalues-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.savevalues","text":"savevalues(u, t, integrator)\n\nReturn a ScaleRecord from u, t, and integrator.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.scale!-Tuple{Any}","page":"Internals","title":"LongwaveModePropagator.scale!","text":"scale!(integrator)\n\nApply wavefield scaling with scalewavefields to the integrator.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.scalewavefields","page":"Internals","title":"LongwaveModePropagator.scalewavefields","text":"scalewavefields(e1, e2)\nscalewavefields(e::SMatrix{4,2})\n\nOrthonormalize the vectors e1 and e2 or the columns of e, and also return the scaling terms a, e1_scale_val, and e2_scale_val applied to the original vectors.\n\nThis first applies Gram-Schmidt orthogonalization and then scales the vectors so they each have length 1, i.e. norm(e1) == norm(e2) == 1. This is the technique suggested by [Pitteway1965] to counter numerical swamping during integration of wavefields.\n\nReferences\n\n[Pitteway1965]: M. L. V. Pitteway, “The numerical calculation of wave-fields, reflexion     coefficients and polarizations for long radio waves in the lower ionosphere. I.,” Phil.     Trans. R. Soc. Lond. A, vol. 257, no. 1079, pp. 219–241, Mar. 1965,     doi: 10.1098/rsta.1965.0004.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals/#LongwaveModePropagator.scalingcondition-Tuple{Any,Any,Any}","page":"Internals","title":"LongwaveModePropagator.scalingcondition","text":"scalingcondition(e, z, int)\n\nReturn true if wavefields should be scaled, otherwise false for wavefields e at height z and integrator int.\n\nWavefields should be scaled if any component of real(e) or imag(e) are >= 1. In addition, force scaling at z <= bottomz to ensure initial upgoing wave is unit amplitude.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.unscalewavefields!-Tuple{Any,DiffEqCallbacks.SavedValues}","page":"Internals","title":"LongwaveModePropagator.unscalewavefields!","text":"unscalewavefields!(e, saved_values::SavedValues)\n\nUnscale the integrated wavefields, a vector of fields at each integration step e, in place.\n\nSee also: unscalewavefields\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.unscalewavefields-Tuple{DiffEqCallbacks.SavedValues}","page":"Internals","title":"LongwaveModePropagator.unscalewavefields","text":"unscalewavefields(saved_values::SavedValues)\n\nReturn the unscaled integrated wavefields originally scaled by scalewavefields.\n\nThe bottom level does not get unscaled. We reference the higher levels to the bottom. The level above the bottom level is additionally scaled by the amount that was applied to originally get from this level down to the bottom level. The next level up (2 above the bottom level) is scaled by the amount applied to the next level and then the bottom level, i.e. we keep track of a cumulative correction on the way back up.\n\nAssumes fields have been scaled by scalewavefields during integration.\n\nSee also: unscalewavefields!\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#LongwaveModePropagator.Waveguide","page":"Internals","title":"LongwaveModePropagator.Waveguide","text":"Waveguide\n\nA waveguide propagation path with a background BField, ionosphere Species, and Ground.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals/#LongwaveModePropagator.adjoint-Tuple{HomogeneousWaveguide}","page":"Internals","title":"LongwaveModePropagator.adjoint","text":"adjoint(w::HomogeneousWaveguide)\n\nReturn w with an adjoint BField having an x component of opposite sign.\n\n\n\n\n\n","category":"method"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/magneticfield.jl\"","category":"page"},{"location":"generated/magneticfield/#Magnetic-field-direction","page":"Magnetic field direction","title":"Magnetic field direction","text":"","category":"section"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"In this example we'll look at the influence of the magnetic field direction on a nighttime ionosphere propagation path. Results will be compared to LWPC.","category":"page"},{"location":"generated/magneticfield/#Generate-scenarios","page":"Magnetic field direction","title":"Generate scenarios","text":"","category":"section"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"We'll use the JSON I/O functionality of LongwaveModePropagator to create the different magnetic field direction scenarios as a BatchInput{BasicInput}. We're doing this to ensure identical inputs are passed to LWPC. Although commented out in the generate function below, we locally saved the BatchInput as a JSON file and used it to feed a custom Python code which generates LWPC input files, runs LWPC, and saves the results in an HDF5 file.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"First load the packages we need.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"using Dates, Printf\nusing HDF5\nusing Plots\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: buildrun, Progress, next!","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"For convenience, we'll define global OUTPUT_RANGES at which the electric field will be computed, and the magnetic field dip and azimuth angles B_DIPS and B_AZS (converted below from degrees to radians).","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"const OUTPUT_RANGES = 0:5e3:3000e3\nconst B_DIPS = [90.0, 60, 60, 60, 60, 60, 60, 60, 60]\nconst B_AZS = [0.0, 0, 45, 90, 135, 180, 225, 270, 315]  ## vertical, N, E, S, W\nnothing  #hide","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"The generate function produces the BatchInput of the scenarios. If we wanted, we could comment out the JSON lines near the bottom of the function to also write the BatchInput to a file. That's not necessary here.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"function generate()\n    batch = BatchInput{BasicInput}()\n    batch.name = \"Magnetic field tests\"\n    batch.description = \"Varying magnetic field directions: vertical, N, E, S, W.\"\n    batch.datetime = Dates.now()\n\n    # Constants\n    frequency = 24e3\n    output_ranges = collect(OUTPUT_RANGES)\n    segment_ranges = [0.0]\n    hprime = [82.0]\n    beta = [0.6]\n\n    # Ocean\n    ground_epsr = [81]\n    ground_sigma = [4.0]\n\n    b_mag = [50e-6]\n    b_dips = deg2rad.(B_DIPS)\n    b_azs = deg2rad.(B_AZS)\n\n    N = length(b_azs)\n    inputs = Vector{BasicInput}(undef, N)\n    for i in 1:N\n        input = BasicInput()\n\n        input.name = @sprintf(\"%d_%.0f_%.0f\", i, b_dips[i], b_azs[i])\n        input.description = \"Wait ionosphere with ocean ground at 24 kHz.\"\n        input.datetime = Dates.now()\n        input.segment_ranges = segment_ranges\n        input.hprimes = hprime\n        input.betas = beta\n        input.b_mags = b_mag\n        input.b_dips = [b_dips[i]]\n        input.b_azs = [b_azs[i]]\n        input.ground_sigmas = ground_sigma\n        input.ground_epsrs = ground_epsr\n        input.frequency = frequency\n        input.output_ranges = output_ranges\n\n        inputs[i] = input\n    end\n    batch.inputs = inputs\n\n    # json_str = JSON3.write(batch)\n    #\n    # open(\"bfields.json\",\"w\") do f\n    #     write(f, json_str)\n    # end\n\n    return batch\nend\n\nbatch = generate();\nnothing #hide","category":"page"},{"location":"generated/magneticfield/#Run-the-model","page":"Magnetic field direction","title":"Run the model","text":"","category":"section"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"Results from my custom LWPC script are saved in an HDF5 file. For easy comparison, we will also save the results from the Longwave Mode Propagator to an HDF5 file. Although not strictly necessary for a small number inputs like we have here, using an HDF5 file rather than the JSON output file that is generated automatically by LongwaveModePropagator when a file is passed to propagate is more robust for thousands or tens of thousands of input scenarios.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"function runlmp(inputs, outfile)\n\n    h5open(outfile, \"cw\") do fid\n        # Create Batch attributes if they don't already exist\n        fid_attrs = attributes(fid)\n        haskey(fid_attrs, \"name\") || (fid_attrs[\"name\"] = inputs.name)\n        haskey(fid_attrs, \"description\") || (fid_attrs[\"description\"] = inputs.description)\n        haskey(fid_attrs, \"datetime\") || (fid_attrs[\"datetime\"] = string(Dates.now()))\n\n        if haskey(fid, \"outputs\")\n            g = fid[\"outputs\"]\n        else\n            g = create_group(fid, \"outputs\")\n        end\n    end\n\n    PM = Progress(length(inputs.inputs), 5)\n    for i in eachindex(inputs.inputs)\n        # If we've already run this, we can skip ahead\n        complete = h5open(outfile, \"r\") do fid\n            g = open_group(fid, \"outputs\")\n            haskey(g, string(i)) ? true : false\n        end\n        complete && (next!(PM); continue)\n\n        output = buildrun(inputs.inputs[i])\n\n        h5open(outfile, \"r+\") do fid\n            g = open_group(fid, \"outputs\")\n            o = create_group(g, string(i))\n            attributes(o)[\"name\"] = output.name\n            attributes(o)[\"description\"] = output.description\n            attributes(o)[\"datetime\"] = string(Dates.now())\n            o[\"output_ranges\"] = output.output_ranges\n            o[\"amplitude\"] = output.amplitude\n            o[\"phase\"] = output.phase\n        end\n        next!(PM)\n    end\nend\nnothing  #hide","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"examples_dir below will need to be modified to the directory where bfields_lmp.h5 is located and where you would like bfields_lmp.h5 to be saved.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"root_dir = dirname(dirname(pathof(LongwaveModePropagator)))\nexamples_dir = joinpath(root_dir, \"examples\")\nlmpfile = joinpath(examples_dir, \"bfields_lmp.h5\")\nrunlmp(batch, lmpfile)","category":"page"},{"location":"generated/magneticfield/#Plots","page":"Magnetic field direction","title":"Plots","text":"","category":"section"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"To more easily compare the amplitude and phase curves, we define a function to process the HDF5 files into arrays of amplitude and phase versus range and magnetic field azimuth.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"function process(outputs)\n    dist = read(outputs[\"outputs\"][\"1\"][\"output_ranges\"])\n    mask = indexin(OUTPUT_RANGES, dist)\n\n    agrid = Array{Float64}(undef, length(OUTPUT_RANGES), length(B_AZS))\n    pgrid = similar(agrid)\n\n    for i in eachindex(B_AZS)\n        o = outputs[\"outputs\"][string(i)]\n\n        amp = read(o[\"amplitude\"])\n        phase = read(o[\"phase\"])\n\n        agrid[:,i] = amp[mask]\n        pgrid[:,i] = rad2deg.(phase[mask])\n    end\n\n    return agrid, pgrid\nend\n\nagrid, pgrid = h5open(lmpfile, \"r\") do o\n    agrid, pgrid = process(o)\nend\n\nnothing  #hide","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"Here is the amplitude plot itself.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"labels = string.(trunc.(Int, B_AZS), \"°\")\nlabels[1] = \"90°, \"*labels[1]\nlabels[2] = \"60°, \"*labels[2]\nlabels[3:end] .= \"      \".*labels[3:end]\n\ncolors = [palette(:phase, length(B_AZS))...]\npushfirst!(colors, RGB(0.0, 0, 0))\n\nplot(OUTPUT_RANGES/1000, agrid,\n     linewidth=1.5, palette=colors, colorbar=false,\n     xlabel=\"range (km)\", ylabel=\"amplitude (dB)\",\n     labels=permutedims(labels), legendtitle=\"  dip, az\", legend=true)\nsavefig(\"magneticfield_amplitude.png\"); nothing # hide","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"(Image: )","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"The amplitude corresponding to each magnetic field azimuth (where 0° is along the propagation direction) is color-coded in the plot above, but a couple of the colors appear to be missing. This is because 0° and 180° are identical. There is no \"north/south\" dependence. Therefore 45°/135° and 315°/225° are also identical.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"On the other hand, there is a significant difference between propagation \"east\" (pinks) versus \"west\" (greens). This effect can be observed in real life.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"Now we'll plot the difference from LWPC.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"lwpcfile = joinpath(examples_dir, \"bfields_lwpc.h5\")\n\nlagrid, lpgrid = h5open(lwpcfile, \"r\") do o\n    lagrid, bpgrid = process(o)\nend\n\nadifference = agrid - lagrid\n\nplot(OUTPUT_RANGES/1000, adifference,\n     linewidth=1.5, palette=colors, colorbar=false,\n     xlabel=\"range (km)\", ylabel=\"amplitude difference (dB)\",\n     labels=permutedims(labels), legendtitle=\"  dip, az\", legend=true)\nsavefig(\"magneticfield_diff.png\"); nothing # hide","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"(Image: )","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"The two models are a very close match. Where there are large differences they occur because of slight misalignment of nulls with respect to range from the transmitter. The 315°/225° line has the worst match, although it is not clear if there is a particular cause for this outside of the general differences between the two models.","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"","category":"page"},{"location":"generated/magneticfield/","page":"Magnetic field direction","title":"Magnetic field direction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"Documentation of LongwaveModePropagator.jl's exported structs and functions.","category":"page"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"Contents","category":"page"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"Basic Functions\nMode Finder\nEigenAngle\nGeophysics\nSamplers\nEmitters\nWaveguides\nIO","category":"page"},{"location":"lib/public/#Basic-Functions","page":"Public Interface","title":"Basic Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"propagate\nLMPParams","category":"page"},{"location":"lib/public/#LongwaveModePropagator.propagate","page":"Public Interface","title":"LongwaveModePropagator.propagate","text":"propagate(waveguide::HomogeneousWaveguide, tx::Emitter, rx::AbstractSampler;\n          modes::Union{Nothing,Vector{EigenAngle}}=nothing, mesh=nothing,\n          params=LMPParams())\n\nCompute electric field E, amplitude, and phase at rx.\n\nPrecomputed waveguide modes can optionally be provided as a Vector{EigenAngle}. By default modes are found with findmodes.\n\nIf mesh = nothing, use defaultmesh to generate mesh for the mode finding algorithm. This is ignored if modes is not nothing.\n\n\n\n\n\npropagate(waveguide::SegmentedWaveguide, tx::Emitter, rx::AbstractSampler;\n          mesh=nothing, params=LMPParams())\n\nCompute electric field E, amplitude, and phase at rx through a SegmentedWaveguide.\n\nIf mesh = nothing, use defaultmesh to generate mesh for the mode finding algorithm.\n\n\n\n\n\npropagate(file::AbstractString, outfile=missing; incrementalwrite=false, append=false,\n          mesh=nothing)\n\nRun the model scenario described by file and save the results as outfile.\n\nIf outfile = missing, the output file name will be $(file)_output.json.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.LMPParams","page":"Public Interface","title":"LongwaveModePropagator.LMPParams","text":"LMPParams{T,T2,H <: AbstractRange{Float64}}\n\nParameters for the LongwaveModePropagator module with defaults:\n\ntopheight::Float64 = 110e3: starting height for integration of the ionosphere reflection   coefficient.\nearthradius::Float64 = 6369: Earth radius in meters.\nearthcurvature::Bool = true: toggle inclusion of Earth curvature in calculations. This   is not supported by all functions.\ncurvatureheight::Float64 = 50e3: reference height for Earth curvature in meters. At this   height, the index of refraction is 1, and is therefore the reference height for   eigenangles.\ngrpfparams::GRPFParams = GRPFParams(100000, 1e-5, true): parameters for the GRPF   complex root-finding algorithm.\nintegrationparams::IntegrationParams{T} =   IntegrationParams(solver=Vern7(), tolerance=1e-8):   parameters passed to DifferentialEquations.jl for integration of the ionosphere   reflection coefficient.\nwavefieldheights::H = range(topheight, 0, length=513): heights in meters at which   wavefields will be integrated.\nwavefieldintegrationparams::IntegrationParams{T2} =   IntegrationParams(solver=Vern7(lazy=false), tolerance=1e-8):   parameters passed to DifferentialEquations.jl for integration of the wavefields   used in mode conversion. The solver cannot be lazy.\n\nThe struct is created using Parameters.jl @with_kw and supports that package's instantiation capabilities, e.g.:\n\np = LMPParams()\np2 = LMPParams(earth_radius=6370e3)\np3 = LMPParams(p2; grpf_params=GRPFParams(100000, 1e-6, true))\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Mode-Finder","page":"Public Interface","title":"Mode Finder","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"findmodes\nPhysicalModeEquation\nsetea\nIntegrationParams","category":"page"},{"location":"lib/public/#LongwaveModePropagator.findmodes","page":"Public Interface","title":"LongwaveModePropagator.findmodes","text":"findmodes(modeequation::ModeEquation, origcoords=nothing; params=LMPParams())\n\nFind EigenAngles associated with modeequation.waveguide within the domain of origcoords.\n\norigcoords should be an array of complex numbers that make up the original grid over which the GRPF algorithm searches for roots of modeequation. If origcoords == nothing, it is computed with defaultmesh.\n\nRoots found by the GRPF algorithm are confirmed to a tolerance of approximately 3 orders of magnitude greater than grpfparams.tolerance in both the real and imaginary component. For example, if grpfparams.tolerance = 1e-5, then the value of the modal equation for each root must be less than 1e-2. Typically the values of each component are close to grpfparams.tolerance.\n\nThere is also a check for redundant modes that requires modes to be separated by at least 2 orders of magnitude greater than grpfparams.tolerance in real and/or imaginary component. For example, if grpfparams.tolerance = 1e-5, then either the real or imaginary component of each mode must be separated by at least 1e-3 from every other mode.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.PhysicalModeEquation","page":"Public Interface","title":"LongwaveModePropagator.PhysicalModeEquation","text":"PhysicalModeEquation{W<:HomogeneousWaveguide} <: ModeEquation\n\nParameters for solving the physical mode equation det(Rg*R - I).\n\nFields:\n\n- ea::EigenAngle\n- frequency::Frequency\n- waveguide::W\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.setea","page":"Public Interface","title":"LongwaveModePropagator.setea","text":"setea(ea, modeequation)\n\nReturn modeequation with eigenangle ea.\n\nea will be converted to an EigenAngle if necessary.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.IntegrationParams","page":"Public Interface","title":"LongwaveModePropagator.IntegrationParams","text":"IntegrationParams{T}\n\nParameters passed to OrdinaryDiffEq.jl during the integration of the ionosphere reflection coefficient matrix in modefinder.jl.\n\nFields\n\ntolerance::Float64 = 1e-8: integration atol and rtol.\nsolver::T = Vern7(): a DifferentialEquations.jl solver.\ndt::Float64 = 1.0: height step in meters (many methods use a variable step size).\nforce_dtmin::Bool = false: if true, continue integration when solver reaches minimum   step size.\nmaxiters::Int = 100_000: maximum number of iterations before stopping.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#EigenAngle","page":"Public Interface","title":"EigenAngle","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"EigenAngle\nattenuation\nphasevelocity\nreferencetoground","category":"page"},{"location":"lib/public/#LongwaveModePropagator.EigenAngle","page":"Public Interface","title":"LongwaveModePropagator.EigenAngle","text":"EigenAngle\n\nPlane-wave propagation direction in angle θ from the vertical in radians.\n\nCommon trigonometric function values of this angle are calculated to increase performance.\n\nFields\n\nθ::ComplexF64\ncosθ::ComplexF64\nsinθ::ComplexF64\nsecθ::ComplexF64\ncos²θ::ComplexF64\nsin²θ::ComplexF64\n\nReal θ will be automatically converted to Complex.\n\nnote: Note\nTechnically this is an angle of incidence from the vertical, and not necessarily an eigenangle unless it is found to be associated with a propagated mode in the waveguide.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.attenuation","page":"Public Interface","title":"LongwaveModePropagator.attenuation","text":"attenuation(ea, frequency::Frequency; params=LMPParams())\n\nCompute attenuation of eigenangle ea at the ground.\n\nea will be converted to an EigenAngle if needed.\n\nThis function internally references ea to the ground.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.phasevelocity","page":"Public Interface","title":"LongwaveModePropagator.phasevelocity","text":"phasevelocity(ea)\n\nCompute the relative phase velocity vc associated with the eigenangle θ.\n\nea will be converted to an EigenAngle if needed.\n\nThis function internally references ea to the ground.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.referencetoground","page":"Public Interface","title":"LongwaveModePropagator.referencetoground","text":"referencetoground(ea::EigenAngle; params=LMPParams())\n\nReference ea from params.curvatureheight to ground (z = 0).\n\n\n\n\n\nreferencetoground(sinθ; params=LMPParams())\n\nReference sin(θ) from params.curvatureheight to the ground and return sin(θ₀) at the ground.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Geophysics","page":"Public Interface","title":"Geophysics","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"BField\nSpecies\nGround\nGROUND\nwaitprofile\nelectroncollisionfrequency\nioncollisionfrequency","category":"page"},{"location":"lib/public/#LongwaveModePropagator.BField","page":"Public Interface","title":"LongwaveModePropagator.BField","text":"BField\n\nBackground magnetic field vector of strength B in Tesla with direction cosines dcl, dcm, and dcn corresponding to x, y, and z directions parallel, perpendicular, and up to the waveguide.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.Species","page":"Public Interface","title":"LongwaveModePropagator.Species","text":"Species{F, G}\n\nIonosphere constituent Species.\n\nFields\n\ncharge::Float64: signed species charged in Coulombs.\nmass::Float64: species mass in kilograms.\nnumberdensity::F: a callable that returns number density in number per cubic meter as a   function of height in meters.\ncollisionfrequency::G: a callable that returns the collision frequency in collisions per   second as a function of height in meters.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.Ground","page":"Public Interface","title":"LongwaveModePropagator.Ground","text":"Ground(ϵᵣ, σ)\n\nIsotropic earth ground characterized by a relative permittivity ϵᵣ and a conductivity σ in Siemens per meter.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.GROUND","page":"Public Interface","title":"LongwaveModePropagator.GROUND","text":"Default ground conductivity indices from LWPC.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#LongwaveModePropagator.waitprofile","page":"Public Interface","title":"LongwaveModePropagator.waitprofile","text":"waitprofile(z, h′, β; cutoff_low=0, threshold=1e12)\n\nCompute the electron number density in electrons per cubic meter at altitude z in meters using Wait's exponential profile [[Wait1964]; [Thomson1993]] with parameters h′ in kilometers and β in inverse kilometers.\n\nThe profile is:\n\nNₑ = 143  10¹³ exp(-015 h) exp(β - 015)(z1000 - h)\n\nOptional arguments:\n\ncutoff_low=0: when z is below cutoff_low, return zero.\nthreshold=1e12: when density is greater than threshold, return threshold.\n\nSee also: electroncollisionfrequency, ioncollisionfrequency\n\nReferences\n\n[Wait1964]: J. R. Wait and K. P. Spies, “Characteristics of the earth-ionosphere waveguide     for VLF radio waves,” U.S. National Bureau of Standards, Boulder, CO, Technical Note     300, Dec. 1964.\n\n[Thomson1993]: N. R. Thomson, “Experimental daytime VLF ionospheric parameters,” Journal of     Atmospheric and Terrestrial Physics, vol. 55, no. 2, pp. 173–184, Feb. 1993,     doi: 10.1016/0021-9169(93)90122-F.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.electroncollisionfrequency","page":"Public Interface","title":"LongwaveModePropagator.electroncollisionfrequency","text":"electroncollisionfrequency(z)\n\nCompute the electron-neutral collision frequency in collisions per second at height z in meters based on Wait's conductivity profile [[Wait1964]; [Thomson1993]].\n\nThe profile is:\n\nνₑ(z) = 1816  10¹¹ exp(-015z1000)\n\nSee also: waitprofile, ioncollisionfrequency\n\nReferences\n\n[Wait1964]: J. R. Wait and K. P. Spies, “Characteristics of the earth-ionosphere waveguide     for VLF radio waves,” U.S. National Bureau of Standards, Boulder, CO, Technical Note     300, Dec. 1964.\n\n[Thomson1993]: N. R. Thomson, “Experimental daytime VLF ionospheric parameters,” Journal of     Atmospheric and Terrestrial Physics, vol. 55, no. 2, pp. 173–184, Feb. 1993,     doi: 10.1016/0021-9169(93)90122-F.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.ioncollisionfrequency","page":"Public Interface","title":"LongwaveModePropagator.ioncollisionfrequency","text":"ioncollisionfrequency(z)\n\nCompute the ion-neutral collision frequency in collisions per second at height z in meters from [Morfitt1976].\n\nThe profile is:\n\nνᵢ(z) = 454  10⁹ exp(-015z1000)\n\nSee also: waitprofile, electroncollisionfrequency\n\nReferences\n\n[Morfitt1976]: D. G. Morfitt and C. H. Shellman, “‘MODESRCH’, an improved computer program     for obtaining ELF/VLF/LF mode constants in an Earth-ionosphere waveguide,” Naval     Electronics Laboratory Center, San Diego, CA, NELC/IR-77T, Oct. 1976.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Samplers","page":"Public Interface","title":"Samplers","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"Sampler\nGroundSampler\nFields","category":"page"},{"location":"lib/public/#LongwaveModePropagator.Sampler","page":"Public Interface","title":"LongwaveModePropagator.Sampler","text":"Sampler{T} <: AbstractSampler{T}\n\nSampler types sample (measure) the electromagnetic field in the waveguide.\n\nFields\n\ndistance::T: ground distance from the transmitter in meters.\nfieldcomponent::Fields.Field: field component measured by the Sampler.\naltitude::Float64: height above the ground in meters.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.GroundSampler","page":"Public Interface","title":"LongwaveModePropagator.GroundSampler","text":"GroundSampler{T} <: AbstractSampler{T}\n\nGroundSamplers are Sampler types with an altitude of zero.\n\nFields\n\ndistance::T: ground distance from the transmitter in meters.\nfieldcomponent::Fields.Field: field component measured by the GroundSampler.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.Fields","page":"Public Interface","title":"LongwaveModePropagator.Fields","text":"Fields\n\nThis baremodule allows scoped enum-like access to electric field components Ex, Ey, and Ez.\n\nExamples\n\njulia> Fields.Ex\nEx::Field = 0\njulia> Fields.Ey\nEy::Field = 1\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#Emitters","page":"Public Interface","title":"Emitters","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"Frequency\nTransmitter\nDipole\nVerticalDipole\nHorizontalDipole\ninclination\nazimuth","category":"page"},{"location":"lib/public/#LongwaveModePropagator.Frequency","page":"Public Interface","title":"LongwaveModePropagator.Frequency","text":"Frequency\n\nElectromagnetic wave defined by frequency f, but also carrying angular wave frequency ω, wavenumber k, and wavelength λ, all in SI units.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.Transmitter","page":"Public Interface","title":"LongwaveModePropagator.Transmitter","text":"Transmitter{A<:Antenna} <: Emitter\n\nTypical ground-based Transmitter.\n\nFields\n\nname::String: transmitter name.\nlatitude::Float64: transmitter geographic latitude in degrees.\nlongitude::Float64: transmitter geographic longitude in degrees.\nantenna::Antenna: transmitter antenna.\nfrequency::Frequency: transmit frequency.\npower::Float64: transmit power in Watts.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.Dipole","page":"Public Interface","title":"LongwaveModePropagator.Dipole","text":"Dipole\n\nDipole antenna with arbitrary orientation described by azimuth_angle and inclination_angle from vertical.\n\nSee also: AbstractDipole\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.VerticalDipole","page":"Public Interface","title":"LongwaveModePropagator.VerticalDipole","text":"VerticalDipole\n\nDipole antenna with inclination angle γ = 0 from the vertical.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.HorizontalDipole","page":"Public Interface","title":"LongwaveModePropagator.HorizontalDipole","text":"HorizontalDipole\n\nDipole antenna with inclination angle γ = π2 from the vertical and azimuth_angle orientation ϕ where:\n\nϕ [rad] orientation\n0 end fire\nπ/2 broadside\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.inclination","page":"Public Interface","title":"LongwaveModePropagator.inclination","text":"inclination(d::AbstractDipole)\n\nReturn the inclination (dip) angle γ of d measured from vertical.\n\nSee also: AbstractDipole\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#LongwaveModePropagator.azimuth","page":"Public Interface","title":"LongwaveModePropagator.azimuth","text":"azimuth(d::AbstractDipole)\n\nReturn the azimuth angle ϕ of d measured towards positive y direction from x.\n\nSee also: AbstractDipole\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Waveguides","page":"Public Interface","title":"Waveguides","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"HomogeneousWaveguide\nSegmentedWaveguide","category":"page"},{"location":"lib/public/#LongwaveModePropagator.HomogeneousWaveguide","page":"Public Interface","title":"LongwaveModePropagator.HomogeneousWaveguide","text":"HomogeneousWaveguide{S} <: Waveguide\n\nDefines a homogeneous segment of waveguide.\n\nFields\n\nbfield::BField: background magnetic field.\nspecies::S: ionosphere constituents.\nground::Ground: waveguide ground.\ndistance::Float64: distance from the Emitter at the start of the segment in meters.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.SegmentedWaveguide","page":"Public Interface","title":"LongwaveModePropagator.SegmentedWaveguide","text":"SegmentedWaveguide{T<:Vector{<:Waveguide}} <: Waveguide\n\nA collection of Waveguides make up an inhomogeneous segmented waveguide.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#IO","page":"Public Interface","title":"IO","text":"","category":"section"},{"location":"lib/public/","page":"Public Interface","title":"Public Interface","text":"BasicInput\nTableInput\nBatchInput\nBasicOutput\nBatchOutput","category":"page"},{"location":"lib/public/#LongwaveModePropagator.BasicInput","page":"Public Interface","title":"LongwaveModePropagator.BasicInput","text":"BasicInput\n\nFields\n\nname::String\ndescription::String\ndatetime::DateTime\nsegment_ranges::Vector{Float64}: distance from transmitter to the beginning of each   HomogeneousWaveguide segment in meters.\nhprimes::Vector{Float64}: Wait's h parameter for each HomogeneousWaveguide segment.\nbetas::Vector{Float64}: Wait's β parameter for each HomogeneousWaveguide segment.\nb_mags::Vector{Float64}: magnetic field magnitude for each HomogeneousWaveguide segment.\nb_dips::Vector{Float64}: magnetic field dip angles in radians for each   HomogeneousWaveguide segment.\nb_azs::Vector{Float64}: magnetic field azimuth in radians \"east\" of the propagation   direction for each HomogeneousWaveguide segment.\nground_sigmas::Vector{Float64}: ground conductivity in Siemens per meter for each   HomogeneousWaveguide segment.\nground_epsrs::Vector{Int}: ground relative permittivity for each HomogeneousWaveguide   segment.\nfrequency::Float64: transmitter frequency in Hertz.\noutput_ranges::Vector{Float64}: distances from the transmitter at which the field will   be calculated.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.TableInput","page":"Public Interface","title":"LongwaveModePropagator.TableInput","text":"TableInput <: Input\n\nFields\n\nname::String\ndescription::String\ndatetime::DateTime\nsegment_ranges::Vector{Float64}: distance from transmitter to the beginning of each   HomogeneousWaveguide segment in meters.\naltitude::Vector{Float64}: altitude above ground in meters for which the density and   collision_frequency profiles are specified.\ndensity::Vector{Float64}: electron density at each altitude in m³.\ncollision_frequency::Vector{Float64}: electron-ion collision frequency at each   altitude in s¹.\nb_dips::Vector{Float64}: magnetic field dip angles in radians for each   HomogeneousWaveguide segment.\nb_azs::Vector{Float64}: magnetic field azimuth in radians \"east\" of the propagation   direction for each HomogeneousWaveguide segment.\nground_sigmas::Vector{Float64}: ground conductivity in Siemens per meter for each   HomogeneousWaveguide segment.\nground_epsrs::Vector{Int}: ground relative permittivity for each HomogeneousWaveguide   segment.\nfrequency::Float64: transmitter frequency in Hertz.\noutput_ranges::Vector{Float64}: distances from the transmitter at which the field will   be calculated.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.BatchInput","page":"Public Interface","title":"LongwaveModePropagator.BatchInput","text":"BatchInput{T} <: Input\n\nA collection of inputs with a batch name, description, and datetime.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.BasicOutput","page":"Public Interface","title":"LongwaveModePropagator.BasicOutput","text":"BasicOutput <: Output\n\nFields\n\nname::String\ndescription::String\ndatetime::DateTime\noutput_ranges::Vector{Float64}\namplitude::Vector{Float64}\nphase::Vector{Float64}\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#LongwaveModePropagator.BatchOutput","page":"Public Interface","title":"LongwaveModePropagator.BatchOutput","text":"BatchOutput{T} <: Output\n\nA collection of outputs with a batch name, description, and datetime.\n\nSee also: BatchInput\n\n\n\n\n\n","category":"type"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/io.jl\"","category":"page"},{"location":"generated/io/#File-based-I/O","page":"File-based I/O","title":"File-based I/O","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"LongwaveModePropagator provides basic propagation capabilities interfacing through JSON files. Julia is still needed to run the model, but scenarios can otherwise be defined and analyzed from e.g. Matlab or Python.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Examples of writing and reading compatible JSON files are provided below for Matlab and Python.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Let's load the necessary packages.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"using Dates\nusing JSON3\n\nusing LongwaveModePropagator\nnothing #hide","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Throughout the examples, we'll also define LMP as shorthand for LongwaveModePropagator when accessing functions from the package that aren't exported.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"const LMP = LongwaveModePropagator\nnothing  #hide","category":"page"},{"location":"generated/io/#Inputs","page":"File-based I/O","title":"Inputs","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"There are two primary ways to define LongwaveModePropagator.Inputs, the abstract supertype for inputing information to the model.","category":"page"},{"location":"generated/io/#basicinput_io","page":"File-based I/O","title":"BasicInput","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"The first is known as a BasicInput. It defines the ionosphere using Wait and Spies h and beta parameters.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"It contains the fields","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"name::String\ndescription::String\ndatetime::DateTime\nsegment_ranges::Vector{Float64}: distance from transmitter to the beginning of each HomogeneousWaveguide segment in meters.\nhprimes::Vector{Float64}: Wait's h parameter for each HomogeneousWaveguide segment.\nbetas::Vector{Float64}: Wait's beta parameter for each HomogeneousWaveguide segment.\nb_mags::Vector{Float64}: magnetic field magnitude for each HomogeneousWaveguide segment.\nb_dips::Vector{Float64}: magnetic field dip angles in radians for each HomogeneousWaveguide segment.\nb_azs::Vector{Float64}: magnetic field azimuth in radians \"east\" of the propagation direction for each HomogeneousWaveguide segment.\nground_sigmas::Vector{Float64}: ground conductivity in Siemens per meter for each HomogeneousWaveguide segment.\nground_epsrs::Vector{Int}: ground relative permittivity for each HomogeneousWaveguide segment.\nfrequency::Float64: transmitter frequency in Hertz.\noutput_ranges::Vector{Float64}: distances from the transmitter at which the field will be calculated.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"The fields that are vectors allow the definition of a SegmentedWaveguide where each element of the vector is its own HomogeneousWaveguide segment. Single element vectors are treated as a single HomogeneousWaveguide.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"To show the equivalent JSON format, we'll build a simple, homogeneous ionosphere BasicInput. It's defined as a mutable struct, so it is simple to specify the fields one by one.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"input = BasicInput()\ninput.name = \"basic\"\ninput.description = \"Test BasicInput\"\ninput.datetime = DateTime(\"2020-12-29T05:00:00.000\")  # usually `Dates.now()`\n\ninput.segment_ranges = [0.0]\ninput.hprimes = [75]\ninput.betas = [0.35]\ninput.b_mags= [50e-6]\ninput.b_dips = [π/2]\ninput.b_azs = [0.0]\ninput.ground_sigmas = [0.001]\ninput.ground_epsrs = [4]\ninput.frequency = 24e3\ninput.output_ranges = collect(0:100e3:1000e3)","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Here it is formatted as JSON.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"json_str = JSON3.pretty(input)","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Let's also save this to a file.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"json_str = JSON3.write(input)\n\nroot_dir = dirname(dirname(pathof(LongwaveModePropagator)))\nexamples_dir = joinpath(root_dir, \"examples\")\nfilename = joinpath(examples_dir, \"basic.json\")\n\nopen(filename,\"w\") do f\n    write(f, json_str)\nend\nnothing  #hide","category":"page"},{"location":"generated/io/#tableinput_io","page":"File-based I/O","title":"TableInput","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"The second input is the TableInput. This type defines the ionosphere using a tabular input of number density and collision frequency as a function of altitude. These tables are then linearly interpolated when integrating the ionosphere reflection coefficient and wavefields (so it's better if these tables are fairly densely sampled with respect to altitude).","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"The fields of the TableInput are","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"name::String\ndescription::String\ndatetime::DateTime\nsegment_ranges::Vector{Float64}: distance from transmitter to the beginning of each HomogeneousWaveguide segment in meters.\naltitude::Vector{Float64}: altitude above ground in meters for which the density and collision_frequency profiles are specified.\ndensity::Vector{Float64}: electron density at each altitude in m³.\ncollision_frequency::Vector{Float64}: electron-ion collision frequency at each altitude in s¹.\nb_dips::Vector{Float64}: magnetic field dip angles in radians for each HomogeneousWaveguide segment.\nb_azs::Vector{Float64}: magnetic field azimuth in radians \"east\" of the propagation direction for each HomogeneousWaveguide segment.\nground_sigmas::Vector{Float64}: ground conductivity in Siemens per meter for each HomogeneousWaveguide segment.\nground_epsrs::Vector{Int}: ground relative permittivity for each HomogeneousWaveguide segment.\nfrequency::Float64: transmitter frequency in Hertz.\noutput_ranges::Vector{Float64}: distances from the transmitter at which the field will be calculated.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Again we'll construct a TableInput to look at the JSON","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"tinput = TableInput()\ntinput.name = \"table\"\ntinput.description = \"Test TableInput\"\ntinput.datetime = DateTime(\"2020-12-29T05:00:00.000\")\n\ntinput.segment_ranges = [0.0]\ntinput.altitude = collect(50e3:5e3:100e3)\ntinput.density = [waitprofile.(tinput.altitude, 75, 0.3)]\ntinput.collision_frequency = [electroncollisionfrequency.(tinput.altitude)]\ntinput.b_mags= [50e-6]\ntinput.b_dips = [π/2]\ntinput.b_azs = [0.0]\ntinput.ground_sigmas = [0.001]\ntinput.ground_epsrs = [4]\ntinput.frequency = 24e3\ntinput.output_ranges = collect(0:100e3:1000e3)\n\njson_str = JSON3.pretty(tinput)","category":"page"},{"location":"generated/io/#batchinput_io","page":"File-based I/O","title":"BatchInput","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Both the BasicInput and TableInput types can be collected together in a BatchInput which has fields for a name, description, datetime, and vector of Inputs. This is useful for keeping a set of scenarios together. See the test/IO.jl file for additional help on how these should be formatted.","category":"page"},{"location":"generated/io/#Running-the-model-from-a-JSON-file","page":"File-based I/O","title":"Running the model from a JSON file","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"To run the model, propagate accepts a filename input (see the help for optional arguments). However, instead of returning a tuple of complex electric field, amplitude, and phase, it returns an Output type. Additionally, it saves the output to a JSON file.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"output = propagate(filename);\nnothing #hide","category":"page"},{"location":"generated/io/#Outputs","page":"File-based I/O","title":"Outputs","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"There are only two LongwaveModePropagator.Output types: BasicOutput and BatchOutput. Both BasicInputs and TableInputs create BasicOutputs, but the BatchInput creates a BatchOutput.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"The BasicOutput contains fields for","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"name::String\ndescription::String\ndatetime::DateTime\noutput_ranges::Vector{Float64}\namplitude::Vector{Float64}\nphase::Vector{Float64}","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"where name and description are directly copied from the input and datetime is when the model was run.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"output","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Not surprisingly, a BatchOutput is simply a container holding a Vector of BasicOutputs, as well as some additional metadata from the corresponding BatchInput.","category":"page"},{"location":"generated/io/#matlab_json","page":"File-based I/O","title":"JSON I/O from Matlab","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Here's an example of how to encode the above BasicInput to JSON and decode the output using Matlab. It's also in the file examples/io.m.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"% Matlab script\n\ninput.name = \"basic\";\ninput.description = \"Test BasicInput\";\ninput.datetime = '2020-12-28T21:06:50.501';\n\ninput.segment_ranges = {0.0};\ninput.hprimes = {75};\ninput.betas = {0.35};\ninput.b_mags = {50e-6};\ninput.b_dips = {pi/2};\ninput.b_azs = {0.0};\ninput.ground_sigmas = {0.001};\ninput.ground_epsrs = {4};\ninput.frequency = 24e3;\ninput.output_ranges = 0:100e3:1000e3;\n\njson_str = jsonencode(input);\n\nfid = fopen('basic_matlab.json', 'w');\nfwrite(fid, json_str, 'char');\nfclose(fid);","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Matlab was used to generate the file basic_matlab.json. We can confirm it's parsed correctly by using the internal LongwaveModePropagator function LongwaveModePropagator.parse, which attempts to parse JSON files into recognized input and output formats.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"matlab_input = LMP.parse(joinpath(examples_dir, \"basic_matlab.json\"))","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Let's run it.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"matlab_output = propagate(joinpath(examples_dir, \"basic_matlab.json\"));\nnothing #hide","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"note: Note\nIt is possible to run Julia as a script, calling it directly from a terminal (see the docs), but it is probably easiest to just run the code from the REPL.cd in a terminal to your working directory\nStart up Julia: julia\nIt's recommended to ] activate ., generating a new environment in this directory\nIf necessary, install LongwaveModePropagator.jl: ] add LongwaveModePropagator\nusing LongwaveModePropagator\npropagate(\"basic_matlab.json\")If this has been done before in the same directory, then just do steps 1, 2, 5, 6.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Reading the results file from Matlab is relatively simple.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"% Matlab script\n\nfilename = 'basic_matlab_output.json';\n\ntext = fileread(filename);\n\noutput = jsondecode(text);","category":"page"},{"location":"generated/io/#python_json","page":"File-based I/O","title":"JSON I/O from Python","text":"","category":"section"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Here is similar code for Python, also available in the file io.py.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"# Python script\n\nimport json\nimport datetime\nimport numpy as np\n\ninput = dict()\n\ninput['name'] = \"basic\"\ninput['description'] = \"Test BasicInput\"\ninput['datetime'] = datetime.datetime.now().isoformat()[:-3]\n\ninput['segment_ranges'] = [0.0]\ninput['hprimes'] = [75]\ninput['betas'] = [0.35]\ninput['b_mags'] = [50e-6]\ninput['b_dips'] = [np.pi/2]\ninput['b_azs'] = [0.0]\ninput['ground_sigmas'] = [0.001]\ninput['ground_epsrs'] = [4]\ninput['frequency'] = 24e3\ninput['output_ranges'] = np.arange(0, 1000e3, 100e3).tolist()\n\njson_str = json.dumps(input)\n\nwith open('basic_python.json', 'w') as file:\n    file.write(json_str)","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"Let's ensure that the JSON file is correctly parsed.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"python_input = LMP.parse(joinpath(examples_dir, \"basic_python.json\"))","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"And run the file.","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"python_output = propagate(joinpath(examples_dir, \"basic_python.json\"));\nnothing #hide","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"To read the results:","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"with open('basic_python_output.json', 'r') as file:\n    output = json.load(file)","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"","category":"page"},{"location":"generated/io/","page":"File-based I/O","title":"File-based I/O","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/interpretinghpbeta.jl\"","category":"page"},{"location":"generated/interpretinghpbeta/#Interpreting-h′-and-β","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"","category":"section"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"This example looks at the influence of h′, β, and radio frequency on amplitude curves.","category":"page"},{"location":"generated/interpretinghpbeta/#Background","page":"Interpreting h′ and β","title":"Background","text":"","category":"section"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"Wait and Spies (1964) is a technical report which characterizes the influence of Earth-ionosphere waveguide parameters on the propagation of VLF radio waves (the attenuation rates, phase velocities, etc.). The report is probably most cited[1] as the source of the exponential electron density profile parameterized by a height h′ (km) and slope β (km⁻¹). The profile is usually written as:","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"N(z) = 143times 10^13 exp(-015 h) exp((beta - 015)(z - h))","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"for density N (m⁻³) and altitude z (km), but as described in Morfitt (1977) or Thomson (1993), Wait and Spies (1964) does not explicitly introduce this form. Instead, Wait introduces a \"conductivity parameter\" omega_r defined by","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"omega_r = omega_p^2nu","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"where omega_p is the angular plasma frequency of the electrons and nu is the effective collision frequency. The height at which omega_r = omega, the angular radio wave frequency is approximately the wave reflection height. This statement is equivalent to X = Z from magnetoionic theory (Ratcliffe (1959))","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"Citing laboratory and some observational experiments, Wait assumes an analytical collision frequency profile","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"nu = 5 times 10^6 exp(-015(z - 70))","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"Using daytime measurements made by the method of partial reflection, he calculates the approximation","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"omega_r = (25times 10^5)exp(03(z - 70))\n\nTo fit measurements made at other times and locations he parameterizes the function\nas","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"math \\omega_r = (2.5 \\times 10^5)\\exp(\\beta(z - h'))","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"where \"``\\beta`` is a constant and ``h'`` is a reference height\" (the height at which\n``\\omega_r = 2.5\\times 10^5``).\nHe immediately suggests ``\\beta = 0.3`` at day and ``\\beta = 0.5`` at night, which are\nlargely considered typical values today.\nWait also parameterizes the collision frequency profile as","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"math \\nu(z) = \\nu_0\\exp(-az).","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"Wait fixed ``a=0.15`` for his studies in the report.\n\n[Morfitt and Shellman (1976)](http://www.dtic.mil/docs/citations/ADA032573)\ncites Wait and Spies and uses","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"math \\nu(z) = 1.82\\times 10^{11} \\exp(-0.15 z)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"from this, it is simple to derive the equation attributed to\nWait and Spies (1964). The ``(\\beta - 0.15)`` term comes from the assumption\n``N(z) = N_0\\exp(bz)`` and ``\\nu(z) = \\nu_0\\exp(-az)`` where ``\\beta = a + b`` and\n``a = 0.15``.\n","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"@example interpretinghpbeta using Plots using LongwaveModePropagator const LMP = LongwaveModePropagator","category":"page"},{"location":"generated/interpretinghpbeta/#Constant-values","page":"Interpreting h′ and β","title":"Constant values","text":"","category":"section"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"bfield = BField(50e-6, π/2, 0) ground = GROUND[5]","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"tx = Transmitter(20e3) rx = GroundSampler(0:5e3:2000e3, Fields.Ez)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"\n## Varying h′\n\nIn this section we set the frequency to 20 kHz, β is set to 0.4 km⁻¹ and we vary h′.\n","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"@example interpretinghpbeta function varyhp(hprimes)     amps = Vector{Vector{Float64}}(undef, length(hprimes))     for i in eachindex(hprimes)         electrons = Species(LMP.QE, LMP.ME, z->waitprofile(z, hprimes[i], 0.4), electroncollisionfrequency)         waveguide = HomogeneousWaveguide(bfield, electrons, ground)         E, a, p = propagate(waveguide, tx, rx)         amps[i] = a     end     return amps end","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"hprimes = 72:1:78 amps = varyhp(hprimes)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"p = plot() function buildplots(p, amps)     cmap = palette(:amp, length(hprimes)+1) # +1 allows us to use a darker lightest color","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"for i in eachindex(hprimes)\n    plot!(p, rx.distance/1000, amps[i],\n          label=hprimes[i], color=cmap[i+1])\nend","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"end buildplots(p, amps) plot!(p, size=(600,400), ylims=(22, 95),       xlabel=\"Range (km)\", ylabel=\"Amplitude (dB)\", legendtitle=\"h′\") savefig(\"interpretinghprimes.png\"); nothing # hide ![](interpretinghprimes.png)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"\nAs h′ increases, the field strength modal interference pattern is displaced outwardly\naway from the transmitter.\n\n## Varying β\n\nNow we'll fix h′ at 78 km and vary β.\n","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"@example interpretinghpbeta function varybeta(betas)     amps = Vector{Vector{Float64}}(undef, length(betas))     for i in eachindex(betas)         electrons = Species(LMP.QE, LMP.ME, z->waitprofile(z, 78, betas[i]), electroncollisionfrequency)         waveguide = HomogeneousWaveguide(bfield, electrons, ground)         E, a, p = propagate(waveguide, tx, rx)         amps[i] = a     end     return amps end","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"betas = [0.3, 0.4, 0.5, 0.7, 0.9, 2.0] amps = varybeta(betas)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"p = plot() function buildplots(p, amps)     cmap = palette(:amp, length(betas)+1)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"for i in eachindex(betas)\n    plot!(p, rx.distance/1000, amps[i],\n          label=betas[i], color=cmap[i+1])\nend","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"end buildplots(p, amps) plot!(p, size=(600,400), ylims=(22, 95),       xlabel=\"Range (km)\", ylabel=\"Amplitude (dB)\", legendtitle=\"β\") savefig(\"interpretinghprimes.png\"); nothing # hide ![](interpretinghprimes.png)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"\nBroadly, the signal increases with increasing β.\nMorfitt (1977) also suggests that an increase in β leads to the signal levels varying\nover a wider range in the regions of strong modal interference.\n\n## Varying frequency\n\nIn this section we'll look at an ionosphere described with typical daytime\nWait profile parameters, but we'll vary the radio frequency from 5 kHz to 50 kHz.\n","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"@example interpretinghpbeta function varyfreq(freqs)     electrons = Species(LMP.QE, LMP.ME, z->waitprofile(z, 75, 0.35), electroncollisionfrequency)     waveguide = HomogeneousWaveguide(bfield, electrons, ground)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"amps = Vector{Vector{Float64}}(undef, length(freqs))\nfor i in eachindex(freqs)\n    tx = Transmitter(freqs[i])\n    E, a, p = propagate(waveguide, tx, rx)\n    amps[i] = a\nend\nreturn amps","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"end","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"freqs = 5e3:5e3:50e3 amps = varyfreq(freqs)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"p = plot() function buildplots(p, amps)","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"\ncdivs = [1, 2, 2, 3, 3, 3, 3, 4, 4, 4]\nNdiv = 6\nd = floor(Int, 100/Ndiv)\n","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"@example interpretinghpbeta     pal = palette(:rainbow, 7)     cmap = [pal[1]; range(pal[2], pal[3], length=2); range(pal[4], pal[5], length=4);             range(pal[6], pal[7], length=3)]","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"for i in eachindex(freqs)\n    fkHz = trunc(Int, freqs[i]/1000)\n    λkm = trunc(LMP.C0/freqs[i]/1000, digits=1)\n    plot!(p, rx.distance/1000, amps[i] .+ (10*i),\n          label=string(fkHz, \",  \", λkm), color=cmap[i])\nend","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"end buildplots(p, amps) plot!(p, size=(600,400),       xlabel=\"Range (km)\", ylabel=\"Amplitude (dB)\", legendtitle=\"f kHz, λ km\") savefig(\"interpretingfrequencies.png\"); nothing # hide ![](interpretingfrequencies.png) ```","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"The effect of increasing frequency is similar to increasing h′. This makes sense because in both cases the waveguide \"height\" in wavelengths is increassing.","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"[1]: As a government technical report and not a journal paper curated by a publishing","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"company, it is difficult to track how many times it has been cited by others.","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"","category":"page"},{"location":"generated/interpretinghpbeta/","page":"Interpreting h′ and β","title":"Interpreting h′ and β","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/meshgrid.jl\"","category":"page"},{"location":"generated/meshgrid/#Mesh-grid-for-mode-finding-Part-1","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"","category":"section"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The Global complex Roots and Poles Finding (GRPF) algorithm searches for roots and poles of complex-valued functions by sampling the function at the nodes of a regular mesh and analyzing the function's complex phase. The mesh search region can be arbitrarily shaped and guarantees that none of the roots/poles can be missed as long as the mesh step is sufficiently small. Specifically, the phase change of the function value cannot exceed three quadrants across mesh edges. Effectively this means there cannot be equal numbers of roots and poles within the boundary of each identified candidate region.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Because the GRPF algorithm uses an adaptive meshing process, the initial mesh node spacing can actually be greater than the distance between the roots/poles of the function, but there is no established method for a priori estimation of the required initial sampling of an arbitrary function. The GRPF algorithm is implemented in RootsAndPoles.jl and used by LongwaveModePropagator to identify eigenangles of HomogeneousWaveguide's. Therefore, we must experimentally determine a sufficient initial mesh grid spacing to identify roots of the mode equation.","category":"page"},{"location":"generated/meshgrid/#Mode-equation","page":"Mesh grid for mode finding - Part 1","title":"Mode equation","text":"","category":"section"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The criteria for mode propagation in the Earth-ionosphere waveguide is described by the fundamental equation of mode theory","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"det(overlinebmR(theta)bmR(theta) - bmI) = 0","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"where overlinebmR(theta) is the reflection coefficient matrix for the ground and bmR(theta) is the reflection coefficient of the ionosphere. Both are functions of the complex angle theta. The discrete values of theta for which the fundamental equation is satisfied are known as eigenangles.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"First, import the necessary packages.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"using Plots\nusing Plots.Measures\nusing RootsAndPoles\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: QE, ME, solvemodalequation, trianglemesh","category":"page"},{"location":"generated/meshgrid/#Exploring-the-mode-equation-phase","page":"Mesh grid for mode finding - Part 1","title":"Exploring the mode equation phase","text":"","category":"section"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The U.S. Navy's Long Wavelength Propagation Capability (LWPC) searches the region of the complex plane from 30° to 90° in the real axis and 0° to -10° in the imaginary axis. The lowest order modes are nearest 90° - i0°, excluding 90°. Modes with large negative imaginary components are highly attenuated and have relatively little affect on the total field in the waveguide.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Let's begin by exploring the modal equation phase on a fine grid across the bottom right complex quadrant.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"We'll define four different PhysicalModeEquation's that we'll use throughout this example.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"lowfrequency = Frequency(10e3)\nmidfrequency = Frequency(20e3)\nhighfrequency = Frequency(100e3)\n\nday = Species(QE, ME, z->waitprofile(z, 75, 0.35), electroncollisionfrequency)\nnight = Species(QE, ME, z->waitprofile(z, 85, 0.9), electroncollisionfrequency)\n\ndaywaveguide = HomogeneousWaveguide(BField(50e-6, π/2, 0), day, GROUND[5])\nnightwaveguide = HomogeneousWaveguide(BField(50e-6, π/2, 0), night, GROUND[5])\n\nday_low_me = PhysicalModeEquation(lowfrequency, daywaveguide)\nday_mid_me = PhysicalModeEquation(midfrequency, daywaveguide)\nday_high_me = PhysicalModeEquation(highfrequency, daywaveguide)\n\nnight_mid_me = PhysicalModeEquation(midfrequency, nightwaveguide)\n\nday_low_title = \"10 kHz\\nh′: 75, β: 0.35\"\nday_mid_title = \"20 kHz\\nh′: 75, β: 0.35\"\nday_high_title = \"100 kHz\\nh′: 75, β: 0.35\"\nnight_mid_title = \"20 kHz\\nh′: 85, β: 0.9\"\nnothing  #hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Here we define a dense rectangular mesh.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Δr = 0.2\nx = 0:Δr:90\ny = -40:Δr:0\nmesh = x .+ im*y';\nnothing #hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Now we simply iterate over each node of the mesh, evaluating the modal equation with LongwaveModePropagator.solvemodalequation, explicitly imported from LongwaveModePropagator above. We use Julia's Threads.@threads multithreading capability to speed up the computation.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"function modeequationphase(me, mesh)\n    phase = Vector{Float64}(undef, length(mesh))\n    Threads.@threads for i in eachindex(mesh)\n        f = solvemodalequation(deg2rad(mesh[i]), me)\n        phase[i] = rad2deg(angle(f))\n    end\n    return phase\nend\n\nphase = modeequationphase(day_mid_me, mesh);\nnothing #hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"If an instability occurs in the integration of the reflection coefficient, it likely happened at the angle 90° + i0°, which is not a valid mode. This isn't a problem for plotting though!","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Plotting the results, we can see that there are clearly identifiable locations where white, black, blue, and orange, each representing a different quadrant of the complex plane, all meet. Each of these locations are either a root or pole in the daytime ionosphere.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"heatmap(x, y, reshape(phase, length(x), length(y))',\n        color=:twilight, clims=(-180, 180),\n        xlims=(0, 90), ylims=(-40, 0),\n        xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n        title=day_mid_title,\n        right_margin=2mm)\nsavefig(\"meshgrid_20kday.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"We can zoom in to the upper right corner of the plot to see the lowest order modes:","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"heatmap(x, y, reshape(phase, length(x), length(y))',\n        color=:twilight, clims=(-180, 180),\n        xlims=(30, 90), ylims=(-10, 0),\n        xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n        title=day_mid_title,\n        right_margin=2mm)\nsavefig(\"meshgrid_20kdayzoom.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"If we switch to a nighttime ionosphere with a high Wait β parameter, we see that the roots move closer to the axes. A perfectly reflecting conductor has eigenangles along the real and complex axes.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"phase = modeequationphase(night_mid_me, mesh);\n\nheatmap(x, y, reshape(phase, length(x), length(y))',\n        color=:twilight, clims=(-180, 180),\n        xlims=(0, 90), ylims=(-40, 0),\n        xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n        title=night_mid_title,\n        right_margin=2mm)\nsavefig(\"meshgrid_20knight.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"At lower frequencies, the roots/poles move further apart.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"phase = modeequationphase(day_low_me, mesh);\n\nheatmap(x, y, reshape(phase, length(x), length(y))',\n        color=:twilight, clims=(-180, 180),\n        xlims=(0, 90), ylims=(-40, 0),\n        xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n        title=day_low_title,\n        right_margin=2mm)\nsavefig(\"meshgrid_10kday.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/#Global-complex-roots-and-poles-finding","page":"Mesh grid for mode finding - Part 1","title":"Global complex roots and poles finding","text":"","category":"section"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The global complex roots and poles finding (GRPF) algorithm is most efficient when the initial mesh grid consists of equilateral triangles. Such a grid can be produced with the rectangulardomain function from RootsAndPoles, but as seen in the evaluation of the modal equation above, no roots or poles appear in the lower right diagonal half of the domain. Even if they did, they would correspond to highly attenuated modes. Therefore, to save compute time, we can exclude the lower right triangle of the domain from the initial mesh.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The function LongwaveModePropagator.trianglemesh is built into LongwaveModePropagator for this purpose. The inputs are specified by the complex bottom left corner zbl, the top right corner ztr, and the mesh spacing Δr in radians.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"zbl = deg2rad(complex(30.0, -10.0))\nztr = deg2rad(complex(89.9, 0.0))\nΔr = deg2rad(0.5)\n\nmesh = trianglemesh(zbl, ztr, Δr);\nnothing #hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"We convert back to degrees just for plotting. Here's a zoomed in portion of the upper right of the domain.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"meshdeg = rad2deg.(mesh)\n\nimg = plot(real(meshdeg), imag(meshdeg), seriestype=:scatter,\n           xlims=(80, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n           legend=false, size=(450,375));\nplot!(img, [80, 90], [0, 0], color=\"red\");\nplot!(img, [0, 90], [-90, 0], color=\"red\")\nsavefig(img, \"meshgrid_trianglemesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Now let's apply grpf to the modal equation on the triangle mesh. grpf adaptively refines the mesh to obtain a more accurate estimate of the position of the roots and poles.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"LMPParams is a struct use for passing parameters across LongwaveModePropagator. Default values are automatically inserted when instantiating the struct. We'll extract the grpfparams field which contains a GRPFParams struct for passing to grpf.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"We will also pass RootsAndPoles' PlotData() argument to obtain additional information on the function phase for plotting.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"params = LMPParams().grpfparams\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, day_mid_me),\n                                                  mesh, PlotData(), params);\nnothing #hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The getplotdata function, provided by RootsAndPoles, is a convenience function for plotting a color-coded tesselation from grpf based on the phase of the function.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"z, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\nzdeg = rad2deg.(z)\n\ntwilightquads = [\n    colorant\"#9E3D36\",\n    colorant\"#C99478\",\n    colorant\"#7599C2\",\n    colorant\"#5C389E\",\n    colorant\"#404040\",\n    RGB(0.0, 0.0, 0.0)\n]\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=day_mid_title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid_20kdaymesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"In the plot above, roots are marked with red circles and poles are marked with red triangles. The automatic refinement of the mesh is clearly visible.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"Here are similar plots for the other three scenarios.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"# Daytime ionosphere, low frequency\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, day_low_me),\n                                                  mesh, PlotData(), params);\nz, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\nzdeg = rad2deg.(z)\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=day_low_title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid_10kdaymesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"At 100 kHz, grpf requires more mesh refinements and takes considerably more time to run.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"# Daytime ionosphere, high frequency\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, day_high_me),\n                                                  mesh, PlotData(), params);\nz, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\nzdeg = rad2deg.(z)\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=day_high_title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid_100kdaymesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"# Nighttime ionosphere, 20 kHz\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, night_mid_me),\n                                                  mesh, PlotData(), params);\nz, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\nzdeg = rad2deg.(z)\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=night_mid_title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid_20knightmesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"(Image: )","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"The example continues in Mesh grid for mode finding - Part 2.","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"","category":"page"},{"location":"generated/meshgrid/","page":"Mesh grid for mode finding - Part 1","title":"Mesh grid for mode finding - Part 1","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/wavefieldintegration.jl\"","category":"page"},{"location":"generated/wavefieldintegration/#Wavefield-integration","page":"Wavefield integration","title":"Wavefield integration","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"The process of mode conversion between two different segments of HomogeneousWaveguide's requires the computation of electromagnetic wavefields from ground to a great height in the ionosphere.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Pitteway (1965) presents one well-known method of integrating the wavefields that breaks the solution for the differential wave equations in the anisotropic ionosphere into solutions for a penetrating and non-penetrating mode. Because of the amplitude of the two waves varies greatly during the integration, Pitteway scales and orthogonalizes the solutions to maintain their independence.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"In this example we'll reproduce the figures in Pitteway's paper.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"First we'll import the necessary packages.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"using CSV, Interpolations\nusing Plots\nusing Plots.Measures\nusing OrdinaryDiffEq\n\nusing TimerOutputs\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: QE, ME\nconst LMP = LongwaveModePropagator\nnothing  #hide","category":"page"},{"location":"generated/wavefieldintegration/#The-ionosphere","page":"Wavefield integration","title":"The ionosphere","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Pitteway uses an ionosphere presented in Piggot et. al., 1965.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"<img src=\"../../images/Piggott_ionosphere.png\"/>","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"He begins with the midday profile with a 16 kHz radio wave at an angle of incidence of 40° from normal. We'll also assume the magnetic field has a strength of 50,000 nT at a dip angle of 68° and azimuth of 111°. Piggott was concerned with a path from Rugby to Cambridge, UK, which, according to the Westinghouse VLF effective-conductivity map, has a ground conductivity index of 8. This can be specified as GROUND[8].","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"ea = EigenAngle(deg2rad(40))\nfrequency = Frequency(16e3)\nbfield = BField(50e-6, deg2rad(68), deg2rad(111))\nground = GROUND[8]","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"To define the electron density and collision frequency profile, we will read in a digitized table of the curves from Piggott and linearly interpolate them. While we're at it, we'll also prepare the nighttime ionosphere.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"root_dir = dirname(dirname(pathof(LongwaveModePropagator)))\nexamples_dir = joinpath(root_dir, \"examples\")\ndata = CSV.File(joinpath(examples_dir, \"piggott1965_data.csv\"))\n\n# interpolation object\nday_itp = interpolate((data.day_ne_z,), data.day_ne, Gridded(Linear()))\nday_etp = extrapolate(day_itp, Line())\ndayfcn(z) = (v = day_etp(z); v > 0 ? v : 0.001)\n\n# night has some rows of `missing` data\nfiltnight_z = collect(skipmissing(data.night_ne_z))\nfiltnight = collect(skipmissing(data.night_ne))\nnight_itp = interpolate((filtnight_z,), filtnight, Gridded(Linear()))\nnight_etp = extrapolate(night_itp, Line())\nnightfcn(z) = (v = night_etp(z); v > 0 ? v : 0.001)\n\n# so does the collision frequency\nfiltnu_z = collect(skipmissing(data.nu_z))\nfiltnu = collect(skipmissing(data.nu))\nnu_itp = interpolate((filtnu_z,), filtnu, Gridded(Linear()))\nnu_etp = extrapolate(nu_itp, Line())\nnufcn(z) = (v = nu_etp(z); v > 0 ? v : 0.001)\n\nday = Species(QE, ME, dayfcn, nufcn)\nnight = Species(QE, ME, nightfcn, nufcn)\n\nnothing  #hide","category":"page"},{"location":"generated/wavefieldintegration/#Scaled,-integrated-wavefields","page":"Wavefield integration","title":"Scaled, integrated wavefields","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"We use the coordinate frame where z is directed upward into the ionosphere, x is along the propagation direction, and y is perpendicular to complete the right-handed system. Where the ionosphere only varies in the z direction, the E_z and H_z fields can be eliminated so that we only need to study the remaining four. The differential equations for the wave in the ionosphere can be written in matrix form for our coordinate system as","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"fracmathrmdbmemathrmdz = -ikbmTbme","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"where","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"bme = beginpmatrix\nE_x  -E_y  H_x  H_y\nendpmatrix","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"and bmT is the 4 times 4 matrix presented in Clemmow and Heading (1954). bmT consists of elements of the susceptibility matrix for the ionosphere (and can be calculated with LongwaveModePropagator.tmatrix).","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"To compute the wavefields, we calculate them at some height z, use mathrmdbmemathrmdz to step to a new height, and repeat from a point high in the ionosphere down to the ground. The initial solution comes from the Booker Quartic, which is a solution for the wavefields in a homogeneous ionosphere. At a great height in the ionosphere, we are interested in the two quartic solutions corresponding to upward-going waves. Therefore, we are integrating two sets of 4 complex variables simultaneously. Throughout the integration, the two solutions lose their independence because of numerical accuracy limitations over a wide range of field magnitudes. To maintain accuracy, the wavefields are orthonomalized repeatedly during the downward integration, and the scaling values are stored so that the fields can be \"recorrected\" after the integration is complete.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Here are what the real component of the E_x1 and H_x2 wavefields looks like with and without the \"recorrection\".","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"zs = 110e3:-50:0\nzskm = zs/1000\n\ne = LMP.integratewavefields(zs, ea, frequency, bfield, day, unscale=true)\ne_unscaled = LMP.integratewavefields(zs, ea, frequency, bfield, day, unscale=false)\n\nex1 = getindex.(e, 1)\nex1_unscaled = getindex.(e_unscaled, 1)\nhx2 = getindex.(e, 7)\nhx2_unscaled = getindex.(e_unscaled, 7)\n\np1 = plot(real(ex1), zskm, title=\"\\$E_{x,1}\\$\",\n          ylims=(0, 90), xlims=(-1.2, 1.2), linewidth=1.5, ylabel=\"altitude (km)\",\n          label=\"corrected\", legend=:topleft);\nplot!(p1, real(ex1_unscaled),\n      zskm, linewidth=1.5, label=\"scaled only\");\n\np2 = plot(real(hx2), zskm, title=\"\\$H_{x,2}\\$\",\n          ylims=(0, 90), xlims=(-1.2, 1.2), linewidth=1.5, legend=false);\nplot!(p2, real(hx2_unscaled),\n      zskm, linewidth=1.5);\n\nplot(p1, p2, layout=(1,2))\nsavefig(\"wavefields_scaling.png\"); nothing # hide","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"(Image: )","category":"page"},{"location":"generated/wavefieldintegration/#Differential-equations-solver","page":"Wavefield integration","title":"Differential equations solver","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Pitteway (1965) used a basic form of a Runge-Kutta integrator with fixed step size. Julia has a fantastic DifferentialEquations suite for integrating many different forms of differential equations. Although wavefields are only computed two times for every transition in a SegmentedWaveguide, we would still like to choose an efficient solver that requires relatively few function calls while still maintaining good accuracy.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Let's try a few different solvers and compare their runtime for the day and night ionospheres.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"We can pass IntegrationParams through the LMPParams struct. Where necessary, we set the lazy interpolant option  of the solvers to false because we discontinuously scale the fields in the middle of the integration and the lazy option is not aware of this.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"TO = TimerOutput()\n\nzs = 110e3:-50:0\nsolvers = [Tsit5(), BS5(lazy=false), OwrenZen5(),\n           Vern6(lazy=false), Vern7(lazy=false), Vern8(lazy=false), Vern9(lazy=false)]\n\nsolverstrings = replace.(string.(solvers), \"OrdinaryDiffEq.\"=>\"\")\n\nday_es = []\nnight_es = []\nfor s in eachindex(solvers)\n    ip = IntegrationParams(solver=solvers[s], tolerance=1e-8)\n    params = LMPParams(wavefieldintegrationparams=ip)\n\n    # make sure method is compiled\n    LMP.integratewavefields(zs, ea, frequency, bfield, day, params=params);\n    LMP.integratewavefields(zs, ea, frequency, bfield, night, params=params);\n\n    solverstring = solverstrings[s]\n    let day_e, night_e\n        # repeat 25 times to average calls\n        for i = 1:25\n            # day ionosphere\n            @timeit TO solverstring begin\n                day_e = LMP.integratewavefields(zs, ea, frequency, bfield, day, params=params)\n            end\n            # night ionosphere\n            @timeit TO solverstring begin\n                night_e = LMP.integratewavefields(zs, ea, frequency, bfield, night, params=params)\n            end\n        end\n        push!(day_es, day_e)\n        push!(night_es, night_e)\n    end\nend","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"A quick plot to ensure none of the methods have problems.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"day_e1s = [getindex.(e, 1) for e in day_es]\n\nplot(real(day_e1s), zs/1000,\n     label=permutedims(solverstrings), legend=:topleft)\nsavefig(\"wavefields_day.png\"); nothing # hide","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"(Image: )","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"And at night...","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"night_e1s = [getindex.(e, 1) for e in night_es]\n\nplot(real(night_e1s), zs/1000,\n     label=permutedims(solverstrings), legend=:topright)\nsavefig(\"wavefields_night.png\"); nothing # hide","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"(Image: )","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"The times to run each...","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"TO","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"The Tsit5, BS5, and 6th, 7th, and 8th order Vern methods all have similar performance. In fact, rerunning these same tests multiple times can result in different solvers being \"fastest\".","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"The DifferentialEquations documents suggest that Verner's methods are preferred over the two lower order methods when solving with the accuracy range ~1e-8-1e-12. We use Vern7(lazy=false)as the default in LongwaveModePropagator. There is no direct MATLAB equivalent to Vern7; it plays a similar role as ode113 (Mathworks suggests ode113 is better at solving problems with stringent error tolerance than ode45). Vern7 is usually more efficient than ode113.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Why not a strict RK4 or a more basic method? I tried them and they produce some discontinuities around the reflection height. It is admittedly difficult to tell if this is a true failure of the methods at this height or a problem related to the scaling and saving callbacks that occur during the integration. In any case, none of the methods tested above exhibit that issue.","category":"page"},{"location":"generated/wavefieldintegration/#Pitteway-figure-2","page":"Wavefield integration","title":"Pitteway figure 2","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Let's reproduce the wavefields in figure 2 of Pitteway (1965).","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"zs = 110e3:-500:50e3\nzskm = zs/1000\n\ne = LMP.integratewavefields(zs, ea, frequency, bfield, day, unscale=true)\n\nex1 = getindex.(e, 1)\ney1 = getindex.(e, 2)\nex2 = getindex.(e, 5)\nhx2 = getindex.(e, 7)\n\nfunction plotfield(field; kwargs...)\n    p = plot(real(field), zskm, color=\"black\", linewidth=1.5, legend=false,\n             xlims=(-0.8, 0.8), label=\"real\",\n             framestyle=:grid; kwargs...)\n    plot!(p, imag(field), zskm, color=\"black\",\n          linewidth=1.5, linestyle=:dash, label=\"imag\")\n    plot!(p, abs.(field), zskm, color=\"black\", linewidth=3, label=\"abs\")\n    plot!(p, -abs.(field), zskm, color=\"black\", linewidth=3, label=\"\")\n    return p\nend\n\nfs = 10\nex1p = plotfield(ex1, ylims=(49, 81), yaxis=false, yformatter=_->\"\");\nannotate!(ex1p, 0.2, 79, text(\"\\$E_{x,1}\\$\", fs));\ney1p = plotfield(ey1, ylims=(49, 81));\nannotate!(ey1p, 0.2, 79, text(\"\\$E_{y,1}\\$\", fs));\nannotate!(ey1p, -0.98, 83, text(\"height (km)\", fs));\nex2p = plotfield(ex2, ylims=(49, 86), yaxis=false, yformatter=_->\"\");\nannotate!(ex2p, 0.3, 84, text(\"\\$E_{x,2}\\$\", fs));\nhx2p = plotfield(hx2, ylims=(49, 86));\nannotate!(hx2p, 0.35, 84, text(\"\\$H_{x,2}\\$\", fs, :center));\nplot(ex1p, ey1p, ex2p, hx2p, layout=(2,2), size=(400,600), top_margin=5mm);\nsavefig(\"wavefields_fig2.png\"); nothing # hide","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"(Image: )","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"<img src=\"../../images/Pitteway1965_fig2.png\"/>","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"The envelopes of the two are very similar. The precise position of the real and imaginary wave components are not important because they each represent an instant in time and change based on the starting height of the integration.","category":"page"},{"location":"generated/wavefieldintegration/#Pitteway-figure-3","page":"Wavefield integration","title":"Pitteway figure 3","text":"","category":"section"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Figure 3 of Pitteway (1965) uses a different scenario. A wave of frequency 202 kHz is at normal incidence through the nighttime ionosphere presented in Piggott (1965).","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"First let's set up the new scenario.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"ea = EigenAngle(0)\nfrequency = Frequency(202e3)\nbfield = BField(50e-6, deg2rad(68), deg2rad(111))\nground = GROUND[8]","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"Now integrating the wavefields.","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"zs = 110e3:-50:70e3\nzskm = zs/1000\n\ne = LMP.integratewavefields(zs, ea, frequency, bfield, night)\n\ney1 = getindex.(e, 2)\nhx2 = getindex.(e, 7)\n\ney1p = plotfield(ey1, ylims=(75, 102), title=\"\\$E_{y,1}\\$\");\nhx2p = plotfield(hx2, ylims=(75, 102), title=\"\\$H_{x,2}\\$\");\nplot(ey1p, hx2p, layout=(1,2), size=(400,500))\nsavefig(\"wavefields_fig3.png\"); nothing # hide","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"(Image: )","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"<img src=\"../../images/Pitteway1965_fig3.png\"/>","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"","category":"page"},{"location":"generated/wavefieldintegration/","page":"Wavefield integration","title":"Wavefield integration","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/meshgrid2.jl\"","category":"page"},{"location":"generated/meshgrid2/#Mesh-grid-for-mode-finding-Part-2","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"","category":"section"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"In Mesh grid for mode finding - Part 1 we used LongwaveModePropagator.trianglemesh to initialize the GRPF grid for mode finding several different ionospheres and transmit frequencies. In part 2 we'll look at where grpf can fail for certain scenarios.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Naturally we want to be able to use the coarsest initial mesh grid as possible because the reflection coefficient has to be integrated through the ionosphere for every node of the grid. This step is by far the most computationally expensive operation of all of LongwaveModePropagator.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"First, let's load the packages needed in this example.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"using Plots\nusing Plots.Measures\nusing RootsAndPoles\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: QE, ME, solvemodalequation, trianglemesh, defaultmesh","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"In the LongwaveModePropagator tests suite, the segmented_scenario is known to miss roots if we use the same trianglemesh parameters (with Δr = deg2rad(0.5)) as in part 1 of the example.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Here we define the HomogeneousWaveguide from the second half of the segmented_scenario known to have the missing roots.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"frequency = Frequency(24e3)\nelectrons = Species(QE, ME, z->waitprofile(z, 80, 0.45), electroncollisionfrequency)\nwaveguide = HomogeneousWaveguide(BField(50e-6, π/2, 0), electrons, Ground(15, 0.001))\nme = PhysicalModeEquation(frequency, waveguide)\ntitle = \"24 kHz\\nh′: 80, β: 0.45\"\nnothing  #hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"First, let's simply compute the mode equation on a fine grid.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Δr = 0.2\nx = 30:Δr:90\ny = -10:Δr:0\nmesh = x .+ 1im*y';\nnothing #hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"As in part 1, we also define a function to compute the modal equation phase.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"function modeequationphase(me, mesh)\n    phase = Vector{Float64}(undef, length(mesh))\n    Threads.@threads for i in eachindex(mesh)\n        f = solvemodalequation(deg2rad(mesh[i]), me)\n        phase[i] = rad2deg(angle(f))\n    end\n    return phase\nend\n\nphase = modeequationphase(me, mesh);\n\nheatmap(x, y, reshape(phase, length(x), length(y))',\n        color=:twilight, clims=(-180, 180),\n        xlims=(30, 90), ylims=(-10, 0),\n        xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n        title=title,\n        right_margin=2mm)\nsavefig(\"meshgrid2_20knight.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"(Image: )","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Let's run the grpf with Δr = 0.5.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"zbl = deg2rad(complex(30.0, -10.0))\nztr = deg2rad(complex(89.9, 0.0))\nΔr = deg2rad(0.5)\n\nmesh = trianglemesh(zbl, ztr, Δr)\n\nparams = LMPParams().grpfparams\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, me),\n                                                  mesh, PlotData(), params);\nz, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nzdeg = rad2deg.(z)\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\n\ntwilightquads = [\n    colorant\"#9E3D36\",\n    colorant\"#C99478\",\n    colorant\"#7599C2\",\n    colorant\"#5C389E\",\n    colorant\"#404040\",\n    RGB(0.0, 0.0, 0.0)\n]\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid2_20knightmesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"(Image: )","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Upon inspection, it is clear that there is a root/pole visible at the upper right corner of the domain in the fine mesh above that is not identified by grpf. In fact, the algorithm did not even try to refine the mesh in this region. That is because the root and pole pair are too closely spaced for the algorithm to know they are there. The discretized Cauchy argument principle (DCAP), upon which GRPF is based, can only identify the presence of roots and poles if there are an unequal number of them. If the complex phase change around a tessellation contour is equal to 0, there may be no roots or poles in the contoured region, or there may be an equal number of roots and poles.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"This run identified 20 roots and 19 poles. Let's run grpf again with a finer resolution of Δr = 0.2.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Δr = deg2rad(0.2)\n\nmesh = trianglemesh(zbl, ztr, Δr)\n\nroots, poles, quads, phasediffs, tess, g2f = grpf(θ->solvemodalequation(θ, me),\n                                                  mesh, PlotData(), params);\nz, edgecolors = getplotdata(tess, quads, phasediffs, g2f)\n\nzdeg = rad2deg.(z)\nrootsdeg = rad2deg.(roots)\npolesdeg = rad2deg.(poles)\n\nimg = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(30, 90), ylims=(-10, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid2_20knightfinemesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"(Image: )","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"This higher resolution initial grid has identified 22 roots and 21 poles. Zooming in on the upper right region, we can see that the previously missing roots and poles are very closely spaced.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"img = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,\n           xlims=(80, 90), ylims=(-2, 0),\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\", legend=false,\n           title=title);\nplot!(img, real(rootsdeg), imag(rootsdeg), color=\"red\",\n      seriestype=:scatter, markersize=5);\nplot!(img, real(polesdeg), imag(polesdeg), color=\"red\",\n      seriestype=:scatter, markershape=:utriangle, markersize=5)\nsavefig(img, \"meshgrid2_20knightfinemeshzoom.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"(Image: )","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"Roots are frequently located closely to poles in the upper right of the domain for a variety of ionospheres. To ensure they are captured, LongwaveModePropagator.defaultmesh uses a spacing of Δr = deg2rad(0.5) for most of the mesh, but a spacing of Δr = deg2rad(0.15) for the region with real greater than 75° and imaginary greater than -1.5°.","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"mesh = defaultmesh(frequency)\nmeshdeg = rad2deg.(mesh)\n\nimg = plot(real(meshdeg), imag(meshdeg), seriestype=:scatter,\n           xlabel=\"real(θ)\", ylabel=\"imag(θ)\",\n           size=(450,375), legend=false);\nplot!(img, [30, 90], [0, 0], color=\"red\");\nplot!(img, [80, 90], [-10, 0], color=\"red\")\nsavefig(img, \"meshgrid2_defaultmesh.png\"); nothing # hide","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"(Image: )","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"","category":"page"},{"location":"generated/meshgrid2/","page":"Mesh grid for mode finding - Part 2","title":"Mesh grid for mode finding - Part 2","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/basic.jl\"","category":"page"},{"location":"generated/basic/#Introduction-to-defining-scenarios","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"This example walks through the basic usage of LongwaveModePropagator when interfacing with the package through Julia.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The simplest way to propagate a transmitted signal in the Earth-ionosphere waveguide is to use the primary function exported by LongwaveModePropagator:","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"propagate(waveguide, tx, rx)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"where waveguide defines the characteristics of the Earth-ionosphere waveguide, tx (\"transmitter\") describes the radiofrequency emitter, and rx (\"receiver\") describes how the electromagnetic field is sampled in the waveguide.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"LongwaveModePropagator exports several structs which are used to define propagation scenarios. We'll break them into two major categories of Transmitters and receivers and Waveguides.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Let's load the necessary packages.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"using Plots\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: QE, ME","category":"page"},{"location":"generated/basic/#Transmitters-and-receivers","page":"Introduction to defining scenarios","title":"Transmitters and receivers","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"This section discusses transmitters and receivers (or emitters and samplers) and the related types.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"We'll begin by looking at the related types that Emitters and Samplers rely on.","category":"page"},{"location":"generated/basic/#Frequencies","page":"Introduction to defining scenarios","title":"Frequencies","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Throughout the code, the electromagnetic wave frequency is required in different forms: as a temporal frequency, angular frequency, or a wave number or wavelength. These are always defined in vacuum.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"For consistency and convenience, LongwaveModePropagator defines a Frequency struct containing fields for:","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"frequency f in Hertz\nangular frequency ω in radians/sec\nwavenumber k in radians/meter\nwavelength λ in meters","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"These fields are automatically calculated when passed a temporal frequency.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"frequency = Frequency(20e3)","category":"page"},{"location":"generated/basic/#Antennas","page":"Introduction to defining scenarios","title":"Antennas","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"LongwaveModePropagator computes the far field in the waveguide produced from energized small dipole antennas of any orientation.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"All antennas are subtypes of the abstract LongwaveModePropagator.Antenna type. Currently all antennas are also subtypes of the LongwaveModePropagator.AbstractDipole type.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The most general antenna is the Dipole, which has azimuth_angle and inclination_angle fields to describe its orientation with respect to the waveguide.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"az = π/4\ninc = π/8\nd = Dipole(az, inc)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"There are also two special cases of Dipole: VerticalDipole and HorizontalDipole. The VerticalDipole struct has no fields. For our purposes, it is fully defined by name alone.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"vd = VerticalDipole()\n\ninclination(vd)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The HorizontalDipole struct has the azimuth_angle field (in radians) to describe its orientation relative to the waveguide.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"hd = HorizontalDipole(az)\n\nrad2deg(inclination(hd))","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"rad2deg(azimuth(hd))","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Additional help can be found by typing ? HorizontalDipole in the REPL.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Why bother defining these types? We make use of multiple dispatch to avoid calculating field terms that are unnecessary for special cases of emitter orientation.","category":"page"},{"location":"generated/basic/#emitters_intro","page":"Introduction to defining scenarios","title":"Emitters","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Emitters emit radiofrequency energy in the waveguide. These are typically large, fixed VLF transmitters on the ground, but they could also be airborne. The type hierarchy in LongwaveModePropagator was designed with the thought that this could potentially be expanded to include natural emitters like lightning, although there is no internal functionality to directly handle such an emitter at this time.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"All emitters subtype the abstract LongwaveModePropagator.Emitter type.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The Transmitter struct is used to define a typical man-made transmitter on the ground. A Transmitter has the fields","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"name::String: transmitter name.\nlatitude::Float64: transmitter geographic latitude in degrees.\nlongitude::Float64: transmitter geographic longitude in degrees.\nantenna::Antenna: transmitter antenna.\nfrequency::Frequency: transmit frequency.\npower::Float64: transmit power in Watts.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Note that currently latitude and longitude are not used. Distances are measured relative to the Emitter without reference to absolute positions.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Several convenience constructors exist to create Transmitters with particular defaults for the remaining fields.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"name = \"NAA\"\nlat = 44.6464\nlon = -67.2811\nf = 24e3\n\ntx = Transmitter(name, lat, lon, f)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"For the common case of transmitters on the ground with antennas modeled as a VerticalDipole, simply specify the transmit frequency.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"tx = Transmitter(f)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Alternately an Antenna, frequency, and power level can be specified.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"power = 500e3  # 500 kW\ntx = Transmitter(hd, f, power)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Although not currently exported by LongwaveModePropagator, there is an LongwaveModePropagator.AirborneTransmitter defined that adds an altitude field to the basic Transmitter object. Further implementation and verification of the radiation resistance of an elevated antenna is required for accurate scaling of the electric field magnitude in the waveguide. In the meantime, if relative amplitude is sufficient, the height gain functions of an elevated transmitter are already incorporated into the model.","category":"page"},{"location":"generated/basic/#samplers_intro","page":"Introduction to defining scenarios","title":"Samplers","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Structs that subtype LongwaveModePropagator.AbstractSampler probe the fields in the waveguide generated by an emitter. In common to all subtypes of AbstractSampler is that they have a position in the guide and specify what field component they sample.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Fields is a baremodule contained within and reexported from LongwaveModePropagator.jl which contains a single enum object","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Fields.Field","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Individual fields are specified with","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"field = Fields.Ez","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The general Sampler type specifies","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"distance::T: ground distance from the transmitter in meters.\nfieldcomponent::Fields.Field: field component measured by the Sampler.\naltitude::Float64: height above the ground in meters.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The distance field is parameterized and therefore could be a single distance e.g. 2250e3, a vector of distances [2000e3, 2100e3, 2500e3], or a range 0:5e3:2000e3, for example.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"There is a special GroundSampler which lacks the altitude field in Samplers because it is known from the type that altitude = 0.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"distance = 2000e3\nrx = GroundSampler(distance, field)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Finally there is a Receiver struct which is defined with a geographic location and Antenna, but it is not exported because geographic information is not currently handled by the package.","category":"page"},{"location":"generated/basic/#waveguides_intro","page":"Introduction to defining scenarios","title":"Waveguides","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The abstract LongwaveModePropagator.Waveguide type is used to describe the earth-ionosphere waveguide with a BField, Species, and Ground.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The basic concrete waveguide type is a HomogeneousWaveguide, with fields","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"bfield::BField: background magnetic field.\nspecies::S: ionosphere constituents.\nground::Ground: waveguide ground.\ndistance::Float64: distance from the Emitter at the start of the segment in meters.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"If not specified, distance is 0. The form of the function call is","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"HomogeneousWaveguide(bfield, species, ground)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"HomogeneousWaveguide should be used when modeling with only a single homogeneous waveguide (ground, ionosphere, and magnetic field) along the propagation path.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"To model an inhomogeneous propagation path, there is a SegmentedWaveguide type. The SegmentedWaveguide is simply a wrapper for a Vector of waveguides.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Let's look at the components of a waveguide.","category":"page"},{"location":"generated/basic/#bfield_intro","page":"Introduction to defining scenarios","title":"BField","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The BField type describes the magnitude and direction of the background magnetic field. Internally it consists of fields for the field strength B in Teslas and direction cosines corresponding to the directions parallel, perpendicular, and up into the waveguide.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"A BField is most commonly constructed by specifying the field strength, dip angle in radians from the horizontal and positive when directed into Earth, and azimuth angle in radians from the propagation direction, positive towards y.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"For example,","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"bfield = BField(50000e-9, π/2, 0)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"bfield is a vertical magnetic field of 50,000 nT.","category":"page"},{"location":"generated/basic/#species_intro","page":"Introduction to defining scenarios","title":"Species","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The Species struct identifies a constituent species of the ionosphere. Species contains the fields","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"charge::Float64: signed species charged in Coulombs.\nmass::Float64: species mass in kilograms.\nnumberdensity::F: a callable that returns number density in number per cubic meter     as a function of height in meters.\ncollisionfrequency::G: a callable that returns the collision frequency in     collisions per second as a function of height in meters.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"numberdensity and collisionfrequency should be \"callables\" (usually Functions) that return the number density and collision frequency, respectively, as a function of height in meters.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"For convenience, the Wait and Spies profile is accessible via waitprofile. Similarly the accompanying collision frequency profiles are electroncollisionfrequency and ioncollisionfrequency.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"To define some electrons for the ionosphere (QE and ME were explicitly imported at the top of the example):","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"h = 75\nβ = 0.35\n\nelectrons = Species(QE, ME, z->waitprofile(z, h, β), electroncollisionfrequency)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Note that we used a lambda function to specify the waitprofile with our given h and beta. Also note that these two parameters are a rare instance of SI units not strictly being followed. See the help for waitprofile for more information, including optional height cutoff and density threshold arguments.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"electroncollisionfrequency is a function of height z only, so it is not necessary to generate a lambda function. We can pass the function handle directly.","category":"page"},{"location":"generated/basic/#ground_intro","page":"Introduction to defining scenarios","title":"Ground","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Ground describes the relative permittivity ϵᵣ and conductivity σ of Earth.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"ground = Ground(10, 2e-4)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"For convenience, a dictionary of common ground indices is exported.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"GROUND","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Dicts aren't sorted, but simply specify the index as the key to access the Ground entry.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"ground = GROUND[5]","category":"page"},{"location":"generated/basic/#Propagating-the-fields:-HomogeneousWaveguide","page":"Introduction to defining scenarios","title":"Propagating the fields: HomogeneousWaveguide","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"We'll redefine everything we've defined above just so they're easier to see, run the model, and plot the results.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"f = 24e3\ntx = Transmitter(f)\n\nranges = 0:5e3:2000e3\nfield = Fields.Ez\nrx = GroundSampler(ranges, field)\n\nbfield = BField(50e-6, π/2, 0)\nelectrons = Species(QE, ME, z->waitprofile(z, 75, 0.35), electroncollisionfrequency)\nground = GROUND[5]\n\nwaveguide = HomogeneousWaveguide(bfield, electrons, ground)","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The propagate function returns a tuple of complex electric field, amplitude in dB μV/m, and phase in radians.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"E, a, p = propagate(waveguide, tx, rx);\nnothing #hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Here are quick plots of the amplitude","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"plot(ranges/1000, a,\n     xlabel=\"range (km)\", ylabel=\"amplitude (dB)\",\n     linewidth=1.5, legend=false)\nsavefig(\"basic_homogeneousamplitude.png\"); nothing # hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"(Image: )","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"and phase.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"plot(ranges/1000, rad2deg.(p),\n     xlabel=\"range (km)\", ylabel=\"phase (deg)\",\n     linewidth=1.5, legend=false)\nsavefig(\"basic_homogeneousphase.png\"); nothing # hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"(Image: )","category":"page"},{"location":"generated/basic/#Propagating-the-fields:-SegmentedWaveguide","page":"Introduction to defining scenarios","title":"Propagating the fields: SegmentedWaveguide","text":"","category":"section"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"As previously mentioned, a SegmentedWaveguide contains a vector of HomogeneousWaveguides. There are many ways to construct a SegmentedWaveguide.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"One common case is when a vector of BFields, Species, and/or Grounds are known for each HomogeneousWaveguide making up the SegmentedWaveguide. We'll also need to specify the distance at which each waveguide segment begins relative to the transmitter.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"The first HomogeneousWaveguide should have a distance of 0. An error will eventually be thrown if that is not the case.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"In this example we'll have two segments. The second segment begins 1000 km away from the transmitter.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"distances = [0.0, 1000e3]\nspecies = [Species(QE, ME, z->waitprofile(z, 75, 0.35), electroncollisionfrequency),\n           Species(QE, ME, z->waitprofile(z, 82, 0.5), electroncollisionfrequency)]\n\nwaveguide = SegmentedWaveguide([HomogeneousWaveguide(bfield, species[i], ground,\n                                                     distances[i]) for i in 1:2]);\nnothing #hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"We can propagate just as before","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"E, a, p = propagate(waveguide, tx, rx);\nnothing #hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Here are quick plots of the amplitude","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"plot(ranges/1000, a,\n     xlabel=\"range (km)\", ylabel=\"amplitude (dB)\",\n     linewidth=1.5, legend=false)\nsavefig(\"basic_segmentedamplitude.png\"); nothing # hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"(Image: )","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"and phase.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"plot(ranges/1000, rad2deg.(p),\n     xlabel=\"range (km)\", ylabel=\"phase (deg)\",\n     linewidth=1.5, legend=false)\nsavefig(\"basic_segmentedphase.png\"); nothing # hide","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"(Image: )","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"Comparing to the plots for the HomogeneousWaveguide above, the results are the same for the first 1000 km and differ for the second 1000 km where there is a different ionosphere in the SegmentedWaveguide scenario.","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"","category":"page"},{"location":"generated/basic/","page":"Introduction to defining scenarios","title":"Introduction to defining scenarios","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"EditURL = \"https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/integratedreflection.jl\"","category":"page"},{"location":"generated/integratedreflection/#Solvers-for-ionosphere-reflection-coefficient","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"","category":"section"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"LongwaveModePropagator uses the technique presented by Budden (1955) to compute the reflection coefficient of a horiontally stratified ionosphere consisting of an anisotropic, collisional plasma.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Budden (1955) derives a differential equation for the reflection coefficient bmR:","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"frac2ikfracmathrmdbmRmathrmdz = W_21 + W_22bmR - bmRW_11 - bmRW_12bmR","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"where W is a 4times 4 matrix divided into four 2times 2 submatrices each containing components of the bmT matrix.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"To obtain the reflection coefficient bmR at any level, we integrate mathrmdbmRmathrmdz downward through the ionosphere from a great height and the height at which we stop is bmR for a sharp boundary at that level with free space below.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"The reflection coefficient matrix bmR consists of four complex reflection coefficients for the different combinations of incident and reflected wave polarization. These reflection coefficients are also functions of the wave angle of incidence, and therefore the integration of mathrmdbmRmathrmdz occurs tens of thousands to hundreds of thousands of times for every HomogeneousWaveguide in the GRPF mode finder. It is therefore extremely important that the differential equations solver be as efficient as possible to minimize runtime. The mode finder is responsible for more than 90% of the runtime of LongwaveModePropagator, and most of the mode finder runtime is the ionosphere reflection coefficient integration.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"In this example, we will compare solvers and tolerances from DifferentialEquations to determine the most efficient combination with reasonable robustness and accuracy. We will begin by looking at the reflection coefficients as a function of height.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"First we load the packages we need.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"using Statistics\nusing Plots\nusing OrdinaryDiffEq\nusing Interpolations\n\nusing LongwaveModePropagator\nusing LongwaveModePropagator: StaticArrays, QE, ME\nconst LMP = LongwaveModePropagator\nnothing  #hide","category":"page"},{"location":"generated/integratedreflection/#R(z)","page":"Solvers for ionosphere reflection coefficient","title":"R(z)","text":"","category":"section"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Let's examine the four reflection coefficients for the ionosphere as a function of height.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"We will use a typical daytime ionosphere with a Wait and Spies (1964) profile and a wave frequency of 24 kHz. The background magnetic field will be vertical with a magnitude of 50,000 nT. We also need to specify the wave angle of incidence on the ionosphere. We'll use a real theta = 75.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"species = Species(QE, ME, z->waitprofile(z, 75, 0.32), electroncollisionfrequency)\nfrequency = Frequency(24e3)\nbfield = BField(50e-6, π/2, 0)\nea = EigenAngle(deg2rad(75));\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"We start the integration at a \"great height\". For longwaves, anything above the D-region is fine. LongwaveModePropagator defaults to a topheight of 110 km.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"topheight = 110e3\nMtop = LMP.susceptibility(topheight, frequency, bfield, species)\nRtop = LMP.bookerreflection(ea, Mtop)","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"The starting solution Rtop comes from a solution of the Booker quartic for the wavefields at topheight.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"We use OrdinaryDiffEq.jl to integrate LongwaveModePropagator.dRdz. Although it's not needed for computing the ionosphere reflection coefficient, dRdz takes a ModeEquation argument, specifying a complete waveguide, including Ground, for convenience.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"ground = GROUND[1]\nwaveguide = HomogeneousWaveguide(bfield, species, ground)\nme = PhysicalModeEquation(ea, frequency, waveguide);\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Then we simply define the ODEProblem and solve.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"prob = ODEProblem{false}(LMP.dRdz, Rtop, (topheight, 0.0), (me, LMPParams()))\n\nsol = solve(prob, RK4(), abstol=1e-9, reltol=1e-9);\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Let's plot the reflection coefficients next to the electron density and collision frequency curves. Because the reflection coefficients are complex-valued, we will plot their magnitude.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"zs = topheight:-1000:0\n\nne = species.numberdensity.(zs)\nnu = species.collisionfrequency.(zs)\nWr = LMP.waitsparameter.(zs, (frequency,), (bfield,), (species,))\n\naltinterp = LinearInterpolation(reverse(Wr), reverse(zs))\neqz = altinterp(frequency.ω)  # altitude where ω = ωᵣ\n\nne[end] = NaN  # otherwise Plots errors\nWr[end] = NaN\n\np1 = plot([ne nu Wr], zs/1000,\n          xlims=(10, 10^10), xaxis=(scale=:log10),\n          ylabel=\"Altitude (km)\",\n          labels=[\"Nₑ (m⁻³)\" \"ν (s⁻¹)\" \"ωᵣ = ωₚ²/ν\"], legend=:topleft,\n          linewidth=1.5);\n\nvline!(p1, [frequency.ω], linestyle=:dash, color=\"gray\", label=\"\");\nhline!(p1, [eqz/1000], linestyle=:dash, color=\"gray\", label=\"\");\nannotate!(p1, frequency.ω, 10, text(\" ω\", :left, 9));\nannotate!(p1, 70, eqz/1000-3, text(\"ωᵣ = ω\", :left, 9));\n\nR11 = abs.(sol(zs, idxs=1))\nR21 = abs.(sol(zs, idxs=2))\nR12 = abs.(sol(zs, idxs=3))\nR22 = abs.(sol(zs, idxs=4))\n\np2 = plot([R11 R21 R12 R22], zs/1000,\n          xlims=(0, 1),\n          yaxis=false, yformatter=_->\"\",\n          legend=:right, labels=[\"R₁₁\" \"R₂₁\" \"R₁₂\" \"R₂₂\"],\n          linewidth=1.5);\n\nhline!(p2, [eqz/1000], linestyle=:dash, color=\"gray\", label=\"\");\n\nplot(p1, p2, layout=(1,2), size=(800, 400))\nsavefig(\"integratedreflection_xyz.png\"); nothing # hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"(Image: )","category":"page"},{"location":"generated/integratedreflection/#Generate-random-scenarios","page":"Solvers for ionosphere reflection coefficient","title":"Generate random scenarios","text":"","category":"section"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Now that we've seen what the reflection coefficient functions look like, we'll focus on finding an accurate but efficient solver.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"We will evaluate the solutions across a range of different random ionospheres, frequencies, and angles of incidence. Each scenario is described by a PhysicalModeEquation.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"function generatescenarios(N)\n    eas = EigenAngle.(complex.(rand(N)*π/2, rand(N)*deg2rad(-10)))\n    frequencies = Frequency.(abs.(randn(N)*60e3))\n\n    B = rand(30e-6:5e-7:60e-6, N)\n    # avoiding within 1° from 0° dip angle\n    bfields = BField.(B, rand(N)*(π/2-0.018) .+ 0.018, rand(N)*2π)\n\n    hps = randn(N)*5 .+ 79\n    betas = randn(N)*0.2 .+ 0.45\n\n    scenarios = Vector{PhysicalModeEquation}(undef, N)\n    for i = 1:N\n        species = Species(QE, ME, z->waitprofile(z, hps[i], betas[i]),\n                          electroncollisionfrequency)\n        ground = GROUND[5]  ## not used\n        waveguide = HomogeneousWaveguide(bfields[i], species, ground)\n\n        me = PhysicalModeEquation(eas[i], frequencies[i], waveguide)\n        scenarios[i] = me\n    end\n\n    return scenarios\nend\n\nscenarios = generatescenarios(30);\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/#Reference-solutions","page":"Solvers for ionosphere reflection coefficient","title":"Reference solutions","text":"","category":"section"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"To evaluate the accuracy of the reflection coefficients, we compare to a very low tolerance Runge-Kutta Order 4 method. The DifferentialEquations implementation of RK4 uses adaptive stepping.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"The LongwaveModePropagator.integratedreflection function does the integration process above for us and returns the reflection coefficient at the ground.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"ip = IntegrationParams(tolerance=1e-14, solver=RK4(), maxiters=1_000_000)\nparams = LMPParams(integrationparams=ip)\n\nRrefs = [LMP.integratedreflection(scenario, params=params) for scenario in scenarios];\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/#Evaluate-solvers","page":"Solvers for ionosphere reflection coefficient","title":"Evaluate solvers","text":"","category":"section"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"Now let's compute and time the results a set of different methods for a range of tolerances. We repeat the integration N = 25 times for each combination of parameters to get a more accurate average time.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"function compute(scenarios, tolerances, solvers)\n    dims = length(scenarios), length(tolerances), length(solvers)\n    Rs = Array{StaticArrays.SMatrix{2,2,ComplexF64,4}}(undef, dims...)\n    times = Array{Float64}(undef, dims...)\n\n    for k in eachindex(solvers)\n        for j in eachindex(tolerances)\n            ip = IntegrationParams(tolerance=tolerances[j], solver=solvers[k])\n            params = LMPParams(integrationparams=ip)\n\n            for i in eachindex(scenarios)\n                # warmup\n                R = LMP.integratedreflection(scenarios[i], params=params)\n\n                # loop for average time\n                N = 25\n                t0 = time_ns()\n                for n = 1:N\n                    R = LMP.integratedreflection(scenarios[i], params=params)\n                end\n                ttotal = time_ns() - t0\n\n                Rs[i,j,k] = R\n                times[i,j,k] = ttotal/N\n            end\n        end\n    end\n    return Rs, times\nend\n\ntolerances = [1e-6, 1e-7, 1e-8, 1e-9, 1e-10]\ntolerancestrings = string.(tolerances)\n\nsolvers = [RK4(), Tsit5(), BS5(), OwrenZen5(), Vern6(), Vern7(), Vern8()]\nsolverstrings = replace.(string.(solvers), \"OrdinaryDiffEq.\"=>\"\")\n\nRs, times = compute(scenarios, tolerances, solvers);\nnothing #hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"We'll measure the error in the reflection coefficient matrices as the maximum absolute difference of the four elements of the matrix compared to the reference reflection coefficient matrix.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"function differr(a, ref)\n    differences = a .- ref\n    aerror = similar(a, Float64)\n    for i in eachindex(differences)\n        absdiff = abs.(differences[i])\n        aerror[i] = maximum(absdiff)\n    end\n    return aerror\nend\n\nRerrs = differr(Rs, Rrefs)\nmean_Rerrs = dropdims(mean(Rerrs, dims=1), dims=1)\n\nheatmap(tolerancestrings, solverstrings, permutedims(log10.(mean_Rerrs)),\n        clims=(-8, -3),\n        xlabel=\"tolerance\", ylabel=\"solver\",\n        colorbar_title=\"log₁₀ max abs difference\", colorbar=true)\nsavefig(\"integratedreflection_difference.png\"); nothing # hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"(Image: )","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"And the average runtimes are","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"mean_times = dropdims(mean(times, dims=1), dims=1)\n\nheatmap(tolerancestrings, solverstrings, permutedims(mean_times)/1e6,\n        clims=(0, 9),\n        xlabel=\"tolerance\", ylabel=\"solver\",\n        colorbar_title=\"time (μs)\", colorbar=true)\nsavefig(\"integratedreflection_time.png\"); nothing # hide","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"(Image: )","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"The best combination of runtime and accuracy occurs at roughly Vern7 with a tolerance of 1e-8. The integration accuracy improves considerably for relatively little additional computation time if the tolerance is changed to 1e-9, but that accuracy is not usually required.","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"","category":"page"},{"location":"generated/integratedreflection/","page":"Solvers for ionosphere reflection coefficient","title":"Solvers for ionosphere reflection coefficient","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#LongwaveModePropagator.jl","page":"Home","title":"LongwaveModePropagator.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Model the propagation of VLF radio waves in the Earth-ionosphere waveguide.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Longwave Mode Propagator is a mode-theory propagation model written in the Julia programming language. The model is largely based on the work of K. G. Budden, who developed both a convenient means of calculating an effective reflection coefficient for the anisotropic ionosphere (Budden, 1955) and a general method for calculating the electric field produced by a source dipole in the Earth-ionosphere waveguide (Budden, 1962). It is similar to the Long Wavelength Propagation Capability, but aims to be more robust and adaptable.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package is most easily used when interfacing with it from Julia, but it can also run simple cases by reading in JSON files and writing the results back to JSON. See the Examples section of these docs for examples of building scenarios and running the model from within Julia or for generating compatible files from Matlab and Python.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download and install a recent version of Julia for your operating system.\nFrom the Julia REPL, install LongwaveModePropagator.jl and its dependencies:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> ]\n(@v1.5) pkg> add https://github.com/fgasdia/LongwaveModePropagator","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you'll be working primarily in Julia, you probably want to cd to your working directory, ] activate a new environment, and then add LongwaveModePropagator (but note that the package is not in Julia's General registry and must be installed with the GitHub URL).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Julia has an excellent built-in package manager (accessed by typing ] from the REPL) that keeps track of the versions of all dependencies within an environment. This means you can leave your code, come back to it two years later on a new computer, and as long as you have all the original files (including the Project.toml and Manifest.toml files), you can instantiate the exact environment you were last working with. To update the environment (while maintaining compatibility across all dependencies), simply ] up.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As with most Julia packages, LongwaveModePropagator is released under the MIT license and all source code is hosted on GitHub. Please open Issues if you find any problems or are interested in new features, or Pull requests if you would like to contribute.","category":"page"},{"location":"#Running-your-first-model","page":"Home","title":"Running your first model","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here's a simple homogeneous ground/ionosphere scenario defined in Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using LongwaveModePropagator\nusing LongwaveModePropagator: QE, ME\n\n# \"standard\" vertical dipole transmitter at 24 kHz\ntx = Transmitter(24e3)\n\n# sample vertical electric field every 5 km out to 2000 km from tx\nrx = GroundSampler(0:5e3:2000e3, Fields.Ez)\n\n# vertical magnetic field\nbfield = BField(50e-6, π/2, 0)\n\n# daytime ionosphere\nelectrons = Species(QE, ME, z->waitprofile(z, 75, 0.35), electroncollisionfrequency)\n\n# \"typical\" earth ground\nground = Ground(10, 1e-4)\n\nwaveguide = HomogeneousWaveguide(bfield, electrons, ground)\n\n# return the complex electric field, amplitude, and phase\nE, a, p = propagate(waveguide, tx, rx);","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can plot the results if we ] add Plots:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Plots\n\nplot(rx.distance/1000, a, xlabel=\"Distance (km)\", ylabel=\"Amplitude (dB μV/m)\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Note\nSI units (MKS) and radians are used throughout LongwaveModePropagator.The only exception in the current version of the package is the use of kilometers and inverse kilometers to define Wait and Spies h and beta parameters for the electron density profile in the function waitprofile. In practice, the units of these parameters are often not specified and implicitly taken to be kilometers and inverse kilometers.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users are encouraged to browse the Examples section for more complex scenarios.","category":"page"},{"location":"#New-to-Julia?","page":"Home","title":"New to Julia?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Julia is a relatively new general programming language that shines for technical computing. It has similarities to Matlab and Python, but is high performance and attempts to solve the \"two language problem\". In part, it achieves its high performance by compiling functions to efficient native code via LLVM. Julia is dynamically typed and uses multiple dispatch, so that the first time a given function is passed arguments of a certain type, the function is compiled for those types. In practice, this means that the first time a function is called, it takes longer than it will on subsequent calls, because at the first call the function also had to be compiled.","category":"page"},{"location":"#Finding-help","page":"Home","title":"Finding help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I highly recommend reading the Julia Documentation. It is very thorough and combines significant textual explanations with examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Besides the regular REPL prompt julia> and the package mode accessed with ], there is also a help mode accessible with ?. The help functionality works \"automatically\", even for user-defined functions with docstrings. Most internal functions of LongwaveModePropagator are documented, so e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"? LongwaveModePropagator.bookerquartic","category":"page"},{"location":"","page":"Home","title":"Home","text":"prints an explanation of the LongwaveModePropagator.bookerquartic function even though it's not exported from the package.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p><a name=\"Budden1955a\"></a>K. G. Budden, “The numerical solution of differential equations governing reflexion of long radio waves from the ionosphere,” Proc. R. Soc. Lond. A, vol. 227, no. 1171, pp. 516–537, Feb. 1955, doi: <a href=\"https://doi.org/10.1098/rspa.1955.0027\">10.1098/rspa.1955.0027</a>.</p>\n\n<p><a name=\"Budden1962\"></a>K. G. Budden, “The influence of the earth’s magnetic field on radio propagation by wave-guide modes,” Proceedings of the Royal Society of London. Series A. Mathematical and Physical Sciences, vol. 265, no. 1323, pp. 538–553, Feb. 1962, doi: <a href=\"https://doi.org/10.1098/rspa.1962.0041\">10.1098/rspa.1962.0041</a>.</p>","category":"page"}]
}
