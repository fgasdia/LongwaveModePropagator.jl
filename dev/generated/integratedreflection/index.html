<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solvers for ionosphere reflection coefficient · LongwaveModePropagator</title><meta name="title" content="Solvers for ionosphere reflection coefficient · LongwaveModePropagator"/><meta property="og:title" content="Solvers for ionosphere reflection coefficient · LongwaveModePropagator"/><meta property="twitter:title" content="Solvers for ionosphere reflection coefficient · LongwaveModePropagator"/><meta name="description" content="Documentation for LongwaveModePropagator."/><meta property="og:description" content="Documentation for LongwaveModePropagator."/><meta property="twitter:description" content="Documentation for LongwaveModePropagator."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LongwaveModePropagator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basic/">Introduction to defining scenarios</a></li><li><a class="tocitem" href="../io/">File-based I/O</a></li><li><a class="tocitem" href="../meshgrid/">Mesh grid for mode finding - Part 1</a></li><li><a class="tocitem" href="../meshgrid2/">Mesh grid for mode finding - Part 2</a></li><li class="is-active"><a class="tocitem" href>Solvers for ionosphere reflection coefficient</a><ul class="internal"><li><a class="tocitem" href="#R(z)"><span>R(z)</span></a></li><li><a class="tocitem" href="#Generate-random-scenarios"><span>Generate random scenarios</span></a></li><li><a class="tocitem" href="#Reference-solutions"><span>Reference solutions</span></a></li><li><a class="tocitem" href="#Evaluate-solvers"><span>Evaluate solvers</span></a></li></ul></li><li><a class="tocitem" href="../wavefieldintegration/">Wavefield integration</a></li><li><a class="tocitem" href="../magneticfield/">Magnetic field direction</a></li><li><a class="tocitem" href="../interpretinghpbeta/">Interpreting h′ and β</a></li><li><a class="tocitem" href="../multiplespecies/">Multiple ionospheric species</a></li><li><a class="tocitem" href="../interpolatingfunctions/">Density and collision frequency as interpolating functions</a></li><li><a class="tocitem" href="../ground/">Ground</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/public/">Public Interface</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Solvers for ionosphere reflection coefficient</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solvers for ionosphere reflection coefficient</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fgasdia/LongwaveModePropagator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fgasdia/LongwaveModePropagator.jl/blob/main/examples/integratedreflection.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Solvers-for-ionosphere-reflection-coefficient"><a class="docs-heading-anchor" href="#Solvers-for-ionosphere-reflection-coefficient">Solvers for ionosphere reflection coefficient</a><a id="Solvers-for-ionosphere-reflection-coefficient-1"></a><a class="docs-heading-anchor-permalink" href="#Solvers-for-ionosphere-reflection-coefficient" title="Permalink"></a></h1><p>LongwaveModePropagator uses the technique presented by <a href="https://doi.org/10.1098/rspa.1955.0027">Budden (1955)</a> to compute the reflection coefficient of a horiontally stratified ionosphere consisting of an anisotropic, collisional plasma.</p><p>Budden (1955) derives a differential equation for the reflection coefficient <span>$\bm{R}$</span>:</p><p class="math-container">\[\frac{2i}{k}\frac{\mathrm{d}\bm{R}}{\mathrm{d}z} = W_{21} + W_{22}\bm{R} - \bm{R}W_{11} - \bm{R}W_{12}\bm{R}\]</p><p>where <span>$W$</span> is a <span>$4\times 4$</span> matrix divided into four <span>$2\times 2$</span> submatrices each containing components of the <span>$\bm{T}$</span> matrix.</p><p>To obtain the reflection coefficient <span>$\bm{R}$</span> at any level, we integrate <span>$\mathrm{d}\bm{R}/\mathrm{d}z$</span> downward through the ionosphere from a great height and the height at which we stop is <span>$\bm{R}$</span> for a sharp boundary at that level with free space below.</p><p>The reflection coefficient matrix <span>$\bm{R}$</span> consists of four complex reflection coefficients for the different combinations of incident and reflected wave polarization. These reflection coefficients are also functions of the wave angle of incidence, and therefore the integration of <span>$\mathrm{d}\bm{R}/\mathrm{d}z$</span> occurs tens of thousands to hundreds of thousands of times for every <code>HomogeneousWaveguide</code> in the GRPF mode finder. It is therefore extremely important that the differential equations solver be as efficient as possible to minimize runtime. The mode finder is responsible for more than 90% of the runtime of LongwaveModePropagator, and most of the mode finder runtime is the ionosphere reflection coefficient integration.</p><p>In this example, we will compare solvers and tolerances from DifferentialEquations to determine the most efficient combination with reasonable robustness and accuracy. We will begin by looking at the reflection coefficients as a function of height.</p><p>First we load the packages we need.</p><pre><code class="language-julia hljs">using Statistics
using Plots
using OrdinaryDiffEq
using Interpolations

using LongwaveModePropagator
using LongwaveModePropagator: StaticArrays, QE, ME
const LMP = LongwaveModePropagator</code></pre><h2 id="R(z)"><a class="docs-heading-anchor" href="#R(z)">R(z)</a><a id="R(z)-1"></a><a class="docs-heading-anchor-permalink" href="#R(z)" title="Permalink"></a></h2><p>Let&#39;s examine the four reflection coefficients for the ionosphere as a function of height.</p><p>We will use a typical daytime ionosphere with a Wait and Spies (1964) profile and a wave frequency of 24 kHz. The background magnetic field will be vertical with a magnitude of 50,000 nT. We also need to specify the wave angle of incidence on the ionosphere. We&#39;ll use a real <span>$\theta = 75°$</span>.</p><pre><code class="language-julia hljs">species = Species(QE, ME, z-&gt;waitprofile(z, 75, 0.32), electroncollisionfrequency)
frequency = Frequency(24e3)
bfield = BField(50e-6, π/2, 0)
ea = EigenAngle(deg2rad(75));</code></pre><p>We start the integration at a &quot;great height&quot;. For longwaves, anything above the D-region is fine. LongwaveModePropagator defaults to a <code>topheight</code> of 110 km.</p><pre><code class="language-julia hljs">topheight = 110e3
Mtop = LMP.susceptibility(topheight, frequency, bfield, species)
Rtop = LMP.bookerreflection(ea, Mtop)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 StaticArraysCore.SMatrix{2, 2, ComplexF64, 4} with indices SOneTo(2)×SOneTo(2):
   0.71414-0.226766im   0.0744954+0.0547451im
 0.0744954+0.0547451im  -0.979616+0.0245265im</code></pre><p>The starting solution <code>Rtop</code> comes from a solution of the Booker quartic for the wavefields at <code>topheight</code>.</p><p>We use OrdinaryDiffEq.jl to integrate <a href="../../lib/internals/#LongwaveModePropagator.dRdz"><code>LongwaveModePropagator.dRdz</code></a>. Although it&#39;s not needed for computing the ionosphere reflection coefficient, <code>dRdz</code> takes a <code>ModeEquation</code> argument, specifying a complete waveguide, including <code>Ground</code>, for convenience.</p><pre><code class="language-julia hljs">ground = GROUND[1]
waveguide = HomogeneousWaveguide(bfield, species, ground)
me = PhysicalModeEquation(ea, frequency, waveguide);</code></pre><p>Then we simply define the <code>ODEProblem</code> and <code>solve</code>.</p><pre><code class="language-julia hljs">prob = ODEProblem{false}(LMP.dRdz, Rtop, (topheight, 0.0), me)

sol = solve(prob, RK4(); abstol=1e-9, reltol=1e-9);</code></pre><p>Let&#39;s plot the reflection coefficients next to the electron density and collision frequency curves. Because the reflection coefficients are complex-valued, we will plot their magnitude.</p><pre><code class="language-julia hljs">zs = topheight:-1000:0

ne = species.numberdensity.(zs)
nu = species.collisionfrequency.(zs)
Wr = LMP.waitsparameter.(zs, (frequency,), (bfield,), (species,))

altinterp = linear_interpolation(reverse(Wr), reverse(zs))
eqz = altinterp(frequency.ω)  # altitude where ω = ωᵣ

ne[end] = NaN  # otherwise Plots errors
Wr[end] = NaN

p1 = plot([ne nu Wr], zs/1000;
          xlims=(10, 10^10), xaxis=(scale=:log10),
          ylabel=&quot;Altitude (km)&quot;,
          labels=[&quot;Nₑ (m⁻³)&quot; &quot;ν (s⁻¹)&quot; &quot;ωᵣ = ωₚ²/ν&quot;], legend=:topleft,
          linewidth=1.5);

vline!(p1, [frequency.ω]; linestyle=:dash, color=&quot;gray&quot;, label=&quot;&quot;);
hline!(p1, [eqz/1000]; linestyle=:dash, color=&quot;gray&quot;, label=&quot;&quot;);
annotate!(p1, frequency.ω, 10, text(&quot; ω&quot;, :left, 9));
annotate!(p1, 70, eqz/1000-3, text(&quot;ωᵣ = ω&quot;, :left, 9));

R11 = vec(abs.(sol(zs; idxs=1)))
R21 = vec(abs.(sol(zs; idxs=2)))
R12 = vec(abs.(sol(zs; idxs=3)))
R22 = vec(abs.(sol(zs; idxs=4)))

p2 = plot([R11 R21 R12 R22], zs/1000;
          xlims=(0, 1),
          yaxis=false, yformatter=_-&gt;&quot;&quot;,
          legend=:right, labels=[&quot;R₁₁&quot; &quot;R₂₁&quot; &quot;R₁₂&quot; &quot;R₂₂&quot;],
          linewidth=1.5);

hline!(p2, [eqz/1000]; linestyle=:dash, color=&quot;gray&quot;, label=&quot;&quot;);

plot(p1, p2; layout=(1,2), size=(800, 400))</code></pre><p><img src="../integratedreflection_xyz.png" alt/></p><h2 id="Generate-random-scenarios"><a class="docs-heading-anchor" href="#Generate-random-scenarios">Generate random scenarios</a><a id="Generate-random-scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Generate-random-scenarios" title="Permalink"></a></h2><p>Now that we&#39;ve seen what the reflection coefficient functions look like, we&#39;ll focus on finding an accurate but efficient solver.</p><p>We will evaluate the solutions across a range of different random ionospheres, frequencies, and angles of incidence. Each scenario is described by a <a href="../../lib/public/#LongwaveModePropagator.PhysicalModeEquation"><code>PhysicalModeEquation</code></a>.</p><pre><code class="language-julia hljs">function generatescenarios(N)
    eas = EigenAngle.(complex.(rand(N)*(π/2-π/6) .+ π/6, rand(N)*deg2rad(-10)))
    frequencies = Frequency.(rand(N)*50e3 .+ 10e3)

    B = rand(30e-6:5e-7:60e-6, N)
    # avoiding within 1° from 0° dip angle
    bfields = BField.(B, rand(N)*(π/2-0.018) .+ 0.018, rand(N)*2π)

    hps = rand(N)*20 .+ 69
    betas = rand(N)*0.8 .+ 0.2

    scenarios = Vector{PhysicalModeEquation}(undef, N)
    for i = 1:N
        species = Species(QE, ME, z-&gt;waitprofile(z, hps[i], betas[i]),
                          electroncollisionfrequency)
        ground = GROUND[5]  ## not used in integration of R
        waveguide = HomogeneousWaveguide(bfields[i], species, ground)

        me = PhysicalModeEquation(eas[i], frequencies[i], waveguide)
        scenarios[i] = me
    end

    return scenarios
end

scenarios = generatescenarios(30);</code></pre><h2 id="Reference-solutions"><a class="docs-heading-anchor" href="#Reference-solutions">Reference solutions</a><a id="Reference-solutions-1"></a><a class="docs-heading-anchor-permalink" href="#Reference-solutions" title="Permalink"></a></h2><p>To evaluate the accuracy of the reflection coefficients, we compare to a very low tolerance Runge-Kutta Order 4 method. The DifferentialEquations implementation of <code>RK4</code> uses adaptive stepping.</p><p>The <a href="../../lib/internals/#LongwaveModePropagator.integratedreflection-Tuple{PhysicalModeEquation, LongwaveModePropagator.Dθ}"><code>LongwaveModePropagator.integratedreflection</code></a> function does the integration process above for us and returns the reflection coefficient at the ground.</p><pre><code class="language-julia hljs">ip = IntegrationParams(tolerance=1e-14, solver=RK4(), maxiters=1_000_000)
params = LMPParams(integrationparams=ip)

Rrefs = [LMP.integratedreflection(scenario; params=params) for scenario in scenarios];</code></pre><h2 id="Evaluate-solvers"><a class="docs-heading-anchor" href="#Evaluate-solvers">Evaluate solvers</a><a id="Evaluate-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Evaluate-solvers" title="Permalink"></a></h2><p>Now let&#39;s compute and time the results a set of different methods for a range of tolerances. We repeat the integration <code>N = 25</code> times for each combination of parameters to get a more accurate average time.</p><pre><code class="language-julia hljs">function compute(scenarios, tolerances, solvers)
    dims = length(scenarios), length(tolerances), length(solvers)
    Rs = Array{StaticArrays.SMatrix{2,2,ComplexF64,4}}(undef, dims...)
    times = Array{Float64}(undef, dims...)

    for k in eachindex(solvers)
        for j in eachindex(tolerances)
            ip = IntegrationParams(tolerance=tolerances[j], solver=solvers[k])
            params = LMPParams(integrationparams=ip)

            for i in eachindex(scenarios)
                # warmup
                R = LMP.integratedreflection(scenarios[i]; params=params)

                # loop for average time
                N = 25
                t0 = time_ns()
                for n = 1:N
                    R = LMP.integratedreflection(scenarios[i]; params=params)
                end
                ttotal = time_ns() - t0

                Rs[i,j,k] = R
                times[i,j,k] = ttotal/N
            end
        end
    end
    return Rs, times
end

tolerances = [1e-4, 1e-5, 1e-6, 1e-7, 1e-8, 1e-9, 1e-10]
tolerancestrings = string.(tolerances)

solvers = [RK4(), Tsit5(), BS5(), OwrenZen5(), Vern6(), Vern7(), Vern8()]
solverstrings = [&quot;RK4&quot;, &quot;Tsit5&quot;, &quot;BS5&quot;, &quot;OwrenZen5&quot;, &quot;Vern6&quot;, &quot;Vern7&quot;, &quot;Vern8&quot;]

Rs, times = compute(scenarios, tolerances, solvers);</code></pre><p>We&#39;ll measure the error in the reflection coefficient matrices as the maximum absolute difference of the four elements of the matrix compared to the reference reflection coefficient matrix.</p><pre><code class="language-julia hljs">function differr(a, ref)
    differences = a .- ref
    aerror = similar(a, Float64)
    for i in eachindex(differences)
        absdiff = abs.(differences[i])
        aerror[i] = maximum(absdiff)
    end
    return aerror
end

Rerrs = differr(Rs, Rrefs)
mean_Rerrs = dropdims(mean(Rerrs; dims=1); dims=1)

heatmap(tolerancestrings, solverstrings, permutedims(log10.(mean_Rerrs));
        clims=(-9, -2),
        xlabel=&quot;tolerance&quot;, ylabel=&quot;solver&quot;,
        colorbar_title=&quot;log₁₀ max abs difference&quot;, colorbar=true)</code></pre><p><img src="../integratedreflection_difference.png" alt/></p><p>And the average runtimes are</p><pre><code class="language-julia hljs">mean_times = dropdims(mean(times; dims=1); dims=1)

heatmap(tolerancestrings, solverstrings, permutedims(mean_times)/1e6;
        clims=(0, 5),
        xlabel=&quot;tolerance&quot;, ylabel=&quot;solver&quot;,
        colorbar_title=&quot;time (μs)&quot;, colorbar=true)</code></pre><p><img src="../integratedreflection_time.png" alt/></p><p>The best accuracy occurs with <code>Vern7</code> and experiment&#39;s we&#39;ve done looking at the sensitivity of the mode solutions to integration tolerance have shown we can get away with a tolerance of <code>1e-4</code>. To play it safe, the default used by LMP is <code>1e-5</code>. The integration accuracy improves considerably for relatively little additional computation time if the tolerance is changed to <code>1e-9</code>, but that accuracy is not required.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meshgrid2/">« Mesh grid for mode finding - Part 2</a><a class="docs-footer-nextpage" href="../wavefieldintegration/">Wavefield integration »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Sunday 31 March 2024 16:03">Sunday 31 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
