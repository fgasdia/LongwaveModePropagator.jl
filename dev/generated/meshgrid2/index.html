<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Mesh grid for mode finding - Part 2 · LongwaveModePropagator</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">LongwaveModePropagator</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../basic/">Introduction to defining scenarios</a></li><li><a class="tocitem" href="../io/">File-based I/O</a></li><li><a class="tocitem" href="../meshgrid/">Mesh grid for mode finding - Part 1</a></li><li class="is-active"><a class="tocitem" href>Mesh grid for mode finding - Part 2</a></li><li><a class="tocitem" href="../integratedreflection/">Solvers for ionosphere reflection coefficient</a></li><li><a class="tocitem" href="../wavefieldintegration/">Wavefield integration</a></li><li><a class="tocitem" href="../magneticfield/">Magnetic field direction</a></li><li><a class="tocitem" href="../interpretinghpbeta/">Interpreting h′ and β</a></li><li><a class="tocitem" href="../ground/">Ground</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/public/">Public Interface</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Mesh grid for mode finding - Part 2</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Mesh grid for mode finding - Part 2</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/fgasdia/LongwaveModePropagator.jl/blob/master/examples/meshgrid2.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Mesh-grid-for-mode-finding-Part-2"><a class="docs-heading-anchor" href="#Mesh-grid-for-mode-finding-Part-2">Mesh grid for mode finding - Part 2</a><a id="Mesh-grid-for-mode-finding-Part-2-1"></a><a class="docs-heading-anchor-permalink" href="#Mesh-grid-for-mode-finding-Part-2" title="Permalink"></a></h1><p>In <a href="../meshgrid/#Mesh-grid-for-mode-finding-Part-1">Mesh grid for mode finding - Part 1</a> we used <a href="../../lib/internals/#LongwaveModePropagator.trianglemesh-Tuple{Any,Any,Any}"><code>LongwaveModePropagator.trianglemesh</code></a> to initialize the GRPF grid for mode finding several different ionospheres and transmit frequencies. In part 2 we&#39;ll look at where <code>grpf</code> can fail for certain scenarios.</p><p>Naturally we want to be able to use the coarsest initial mesh grid as possible because the reflection coefficient has to be integrated through the ionosphere for every node of the grid. This step is by far the most computationally expensive operation of all of LongwaveModePropagator.</p><p>First, let&#39;s load the packages needed in this example.</p><pre><code class="language-julia">using Plots
using Plots.Measures
using RootsAndPoles

using LongwaveModePropagator
using LongwaveModePropagator: QE, ME, solvemodalequation, trianglemesh, defaultmesh</code></pre><p>In the LongwaveModePropagator tests suite, the <code>segmented_scenario</code> is known to miss roots if we use the same <code>trianglemesh</code> parameters (with <code>Δr = deg2rad(0.5)</code>) as in part 1 of the example.</p><p>Here we define the <code>HomogeneousWaveguide</code> from the second half of the <code>segmented_scenario</code> known to have the missing roots.</p><pre><code class="language-julia">frequency = Frequency(24e3)
electrons = Species(QE, ME, z-&gt;waitprofile(z, 80, 0.45), electroncollisionfrequency)
waveguide = HomogeneousWaveguide(BField(50e-6, π/2, 0), electrons, Ground(15, 0.001))
me = PhysicalModeEquation(frequency, waveguide)
title = &quot;24 kHz\nh′: 80, β: 0.45&quot;</code></pre><p>First, let&#39;s simply compute the mode equation on a fine grid.</p><pre><code class="language-julia">Δr = 0.2
x = 30:Δr:90
y = -10:Δr:0
mesh = x .+ 1im*y&#39;;</code></pre><p>As in part 1, we also define a function to compute the modal equation phase.</p><pre><code class="language-julia">function modeequationphase(me, mesh)
    phase = Vector{Float64}(undef, length(mesh))
    Threads.@threads for i in eachindex(mesh)
        f = solvemodalequation(deg2rad(mesh[i]), me)
        phase[i] = rad2deg(angle(f))
    end
    return phase
end

phase = modeequationphase(me, mesh);

heatmap(x, y, reshape(phase, length(x), length(y))&#39;,
        color=:twilight, clims=(-180, 180),
        xlims=(30, 90), ylims=(-10, 0),
        xlabel=&quot;real(θ)&quot;, ylabel=&quot;imag(θ)&quot;,
        title=title,
        right_margin=2mm)</code></pre><pre class="documenter-example-output">┌ Warning: Instability detected. Aborting
└ @ SciMLBase ~/.julia/packages/SciMLBase/sRVBG/src/integrator_interface.jl:348</pre><p><img src="../meshgrid2_20knight.png" alt/></p><p>Let&#39;s run the <code>grpf</code> with <code>Δr = 0.5</code>.</p><pre><code class="language-julia">zbl = deg2rad(complex(30.0, -10.0))
ztr = deg2rad(complex(89.9, 0.0))
Δr = deg2rad(0.5)

mesh = trianglemesh(zbl, ztr, Δr)

params = LMPParams().grpfparams
roots, poles, quads, phasediffs, tess, g2f = grpf(θ-&gt;solvemodalequation(θ, me),
                                                  mesh, PlotData(), params);
z, edgecolors = getplotdata(tess, quads, phasediffs, g2f)

zdeg = rad2deg.(z)
rootsdeg = rad2deg.(roots)
polesdeg = rad2deg.(poles)

twilightquads = [
    colorant&quot;#9E3D36&quot;,
    colorant&quot;#C99478&quot;,
    colorant&quot;#7599C2&quot;,
    colorant&quot;#5C389E&quot;,
    colorant&quot;#404040&quot;,
    RGB(0.0, 0.0, 0.0)
]

img = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,
           xlims=(30, 90), ylims=(-10, 0),
           xlabel=&quot;real(θ)&quot;, ylabel=&quot;imag(θ)&quot;, legend=false,
           title=title);
plot!(img, real(rootsdeg), imag(rootsdeg), color=&quot;red&quot;,
      seriestype=:scatter, markersize=5);
plot!(img, real(polesdeg), imag(polesdeg), color=&quot;red&quot;,
      seriestype=:scatter, markershape=:utriangle, markersize=5)</code></pre><p><img src="../meshgrid2_20knightmesh.png" alt/></p><p>Upon inspection, it is clear that there is a root/pole visible at the upper right corner of the domain in the fine mesh above that is not identified by <code>grpf</code>. In fact, the algorithm did not even try to refine the mesh in this region. That is because the root and pole pair are too closely spaced for the algorithm to know they are there. The discretized Cauchy <a href="https://en.wikipedia.org/wiki/Argument_principle">argument principle</a> (DCAP), upon which GRPF is based, can only identify the presence of roots and poles if there are an unequal number of them. If the complex phase change around a tessellation contour is equal to 0, there may be no roots or poles in the contoured region, or there may be an equal number of roots and poles.</p><p>This run identified 20 roots and 19 poles. Let&#39;s run <code>grpf</code> again with a finer resolution of <code>Δr = 0.2</code>.</p><pre><code class="language-julia">Δr = deg2rad(0.2)

mesh = trianglemesh(zbl, ztr, Δr)

roots, poles, quads, phasediffs, tess, g2f = grpf(θ-&gt;solvemodalequation(θ, me),
                                                  mesh, PlotData(), params);
z, edgecolors = getplotdata(tess, quads, phasediffs, g2f)

zdeg = rad2deg.(z)
rootsdeg = rad2deg.(roots)
polesdeg = rad2deg.(poles)

img = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,
           xlims=(30, 90), ylims=(-10, 0),
           xlabel=&quot;real(θ)&quot;, ylabel=&quot;imag(θ)&quot;, legend=false,
           title=title);
plot!(img, real(rootsdeg), imag(rootsdeg), color=&quot;red&quot;,
      seriestype=:scatter, markersize=5);
plot!(img, real(polesdeg), imag(polesdeg), color=&quot;red&quot;,
      seriestype=:scatter, markershape=:utriangle, markersize=5)</code></pre><p><img src="../meshgrid2_20knightfinemesh.png" alt/></p><p>This higher resolution initial grid has identified 22 roots and 21 poles. Zooming in on the upper right region, we can see that the previously missing roots and poles are very closely spaced.</p><pre><code class="language-julia">img = plot(real(zdeg), imag(zdeg), group=edgecolors, palette=twilightquads, linewidth=1.5,
           xlims=(80, 90), ylims=(-2, 0),
           xlabel=&quot;real(θ)&quot;, ylabel=&quot;imag(θ)&quot;, legend=false,
           title=title);
plot!(img, real(rootsdeg), imag(rootsdeg), color=&quot;red&quot;,
      seriestype=:scatter, markersize=5);
plot!(img, real(polesdeg), imag(polesdeg), color=&quot;red&quot;,
      seriestype=:scatter, markershape=:utriangle, markersize=5)</code></pre><p><img src="../meshgrid2_20knightfinemeshzoom.png" alt/></p><p>Roots are frequently located closely to poles in the upper right of the domain for a variety of ionospheres. To ensure they are captured, <a href="../../lib/internals/#LongwaveModePropagator.defaultmesh-Tuple{Any}"><code>LongwaveModePropagator.defaultmesh</code></a> uses a spacing of <code>Δr = deg2rad(0.5)</code> for most of the mesh, but a spacing of <code>Δr = deg2rad(0.15)</code> for the region with real greater than 75° and imaginary greater than -1.5°.</p><pre><code class="language-julia">mesh = defaultmesh(frequency)
meshdeg = rad2deg.(mesh)

img = plot(real(meshdeg), imag(meshdeg), seriestype=:scatter,
           xlabel=&quot;real(θ)&quot;, ylabel=&quot;imag(θ)&quot;,
           size=(450,375), legend=false);
plot!(img, [30, 90], [0, 0], color=&quot;red&quot;);
plot!(img, [80, 90], [-10, 0], color=&quot;red&quot;)</code></pre><p><img src="../meshgrid2_defaultmesh.png" alt/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../meshgrid/">« Mesh grid for mode finding - Part 1</a><a class="docs-footer-nextpage" href="../integratedreflection/">Solvers for ionosphere reflection coefficient »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 28 February 2021 05:46">Sunday 28 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
