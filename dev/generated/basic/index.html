<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction to defining scenarios · LongwaveModePropagator</title><meta name="title" content="Introduction to defining scenarios · LongwaveModePropagator"/><meta property="og:title" content="Introduction to defining scenarios · LongwaveModePropagator"/><meta property="twitter:title" content="Introduction to defining scenarios · LongwaveModePropagator"/><meta name="description" content="Documentation for LongwaveModePropagator."/><meta property="og:description" content="Documentation for LongwaveModePropagator."/><meta property="twitter:description" content="Documentation for LongwaveModePropagator."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LongwaveModePropagator</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Introduction to defining scenarios</a><ul class="internal"><li><a class="tocitem" href="#Transmitters-and-receivers"><span>Transmitters and receivers</span></a></li><li><a class="tocitem" href="#waveguides_intro"><span>Waveguides</span></a></li><li><a class="tocitem" href="#Propagating-the-fields:-HomogeneousWaveguide"><span>Propagating the fields: HomogeneousWaveguide</span></a></li><li><a class="tocitem" href="#Propagating-the-fields:-SegmentedWaveguide"><span>Propagating the fields: SegmentedWaveguide</span></a></li><li><a class="tocitem" href="#LMPParams"><span><code>LMPParams</code></span></a></li></ul></li><li><a class="tocitem" href="../io/">File-based I/O</a></li><li><a class="tocitem" href="../meshgrid/">Mesh grid for mode finding - Part 1</a></li><li><a class="tocitem" href="../meshgrid2/">Mesh grid for mode finding - Part 2</a></li><li><a class="tocitem" href="../integratedreflection/">Solvers for ionosphere reflection coefficient</a></li><li><a class="tocitem" href="../wavefieldintegration/">Wavefield integration</a></li><li><a class="tocitem" href="../magneticfield/">Magnetic field direction</a></li><li><a class="tocitem" href="../interpretinghpbeta/">Interpreting h′ and β</a></li><li><a class="tocitem" href="../multiplespecies/">Multiple ionospheric species</a></li><li><a class="tocitem" href="../interpolatingfunctions/">Density and collision frequency as interpolating functions</a></li><li><a class="tocitem" href="../ground/">Ground</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Library</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../lib/public/">Public Interface</a></li><li><a class="tocitem" href="../../lib/internals/">Internals</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Introduction to defining scenarios</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction to defining scenarios</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/fgasdia/LongwaveModePropagator.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/fgasdia/LongwaveModePropagator.jl/blob/main/examples/basic.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Introduction-to-defining-scenarios"><a class="docs-heading-anchor" href="#Introduction-to-defining-scenarios">Introduction to defining scenarios</a><a id="Introduction-to-defining-scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction-to-defining-scenarios" title="Permalink"></a></h1><p>This example walks through the basic usage of LongwaveModePropagator when interfacing with the package through Julia.</p><p>The simplest way to propagate a transmitted signal in the Earth-ionosphere waveguide is to use the primary function exported by LongwaveModePropagator:</p><p><code>propagate(waveguide, tx, rx)</code></p><p>where <code>waveguide</code> defines the characteristics of the Earth-ionosphere waveguide, <code>tx</code> (&quot;transmitter&quot;) describes the radiofrequency emitter, and <code>rx</code> (&quot;receiver&quot;) describes how the electromagnetic field is sampled in the waveguide.</p><p>LongwaveModePropagator exports several structs which are used to define propagation scenarios. We&#39;ll break them into two major categories of <a href="#Transmitters-and-receivers">Transmitters and receivers</a> and <a href="#waveguides_intro">Waveguides</a>.</p><p>Let&#39;s load the necessary packages.</p><pre><code class="language-julia hljs">using Plots

using LongwaveModePropagator
using LongwaveModePropagator: QE, ME</code></pre><h2 id="Transmitters-and-receivers"><a class="docs-heading-anchor" href="#Transmitters-and-receivers">Transmitters and receivers</a><a id="Transmitters-and-receivers-1"></a><a class="docs-heading-anchor-permalink" href="#Transmitters-and-receivers" title="Permalink"></a></h2><p>This section discusses transmitters and receivers (or <em>emitters</em> and <em>samplers</em>) and the related types.</p><p>We&#39;ll begin by looking at the related types that <code>Emitter</code>s and <code>Sampler</code>s rely on.</p><h3 id="Frequencies"><a class="docs-heading-anchor" href="#Frequencies">Frequencies</a><a id="Frequencies-1"></a><a class="docs-heading-anchor-permalink" href="#Frequencies" title="Permalink"></a></h3><p>Throughout the code, the electromagnetic wave frequency is required in different forms: as a temporal frequency, angular frequency, or a wave number or wavelength. These are always defined in vacuum.</p><p>For consistency and convenience, LongwaveModePropagator defines a <a href="../../lib/public/#LongwaveModePropagator.Frequency"><code>Frequency</code></a> struct containing fields for:</p><ul><li>frequency <code>f</code> in Hertz</li><li>angular frequency <code>ω</code> in radians/sec</li><li>wavenumber <code>k</code> in radians/meter</li><li>wavelength <code>λ</code> in meters</li></ul><p>These fields are automatically calculated when passed a temporal frequency.</p><pre><code class="language-julia hljs">frequency = Frequency(20e3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Frequency(20000.0, 125663.70614359173, 0.00041916900439033635, 14989.6229)</code></pre><h3 id="Antennas"><a class="docs-heading-anchor" href="#Antennas">Antennas</a><a id="Antennas-1"></a><a class="docs-heading-anchor-permalink" href="#Antennas" title="Permalink"></a></h3><p>LongwaveModePropagator computes the far field in the waveguide produced from energized small dipole antennas of any orientation.</p><p>All antennas are subtypes of the abstract <a href="../../lib/internals/#LongwaveModePropagator.Antenna"><code>LongwaveModePropagator.Antenna</code></a> type. Currently all antennas are also subtypes of the <a href="../../lib/internals/#LongwaveModePropagator.AbstractDipole"><code>LongwaveModePropagator.AbstractDipole</code></a> type.</p><p>The most general antenna is the <a href="../../lib/public/#LongwaveModePropagator.Dipole"><code>Dipole</code></a>, which has <code>azimuth_angle</code> and <code>inclination_angle</code> fields to describe its orientation with respect to the waveguide.</p><pre><code class="language-julia hljs">az = π/4
inc = π/8
d = Dipole(az, inc)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dipole(0.7853981633974483, 0.39269908169872414)</code></pre><p>There are also two special cases of <code>Dipole</code>: <a href="../../lib/public/#LongwaveModePropagator.VerticalDipole"><code>VerticalDipole</code></a> and <a href="../../lib/public/#LongwaveModePropagator.HorizontalDipole"><code>HorizontalDipole</code></a>. The <a href="../../lib/public/#LongwaveModePropagator.VerticalDipole"><code>VerticalDipole</code></a> struct has no fields. For our purposes, it is fully defined by name alone.</p><pre><code class="language-julia hljs">vd = VerticalDipole()

inclination(vd)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.0</code></pre><p>The <a href="../../lib/public/#LongwaveModePropagator.HorizontalDipole"><code>HorizontalDipole</code></a> struct has the <code>azimuth_angle</code> field (in <em>radians</em>) to describe its orientation relative to the waveguide.</p><pre><code class="language-julia hljs">hd = HorizontalDipole(az)

rad2deg(inclination(hd))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">90.0</code></pre><pre><code class="language-julia hljs">rad2deg(azimuth(hd))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">45.0</code></pre><p>Additional help can be found by typing <code>? HorizontalDipole</code> in the REPL.</p><p>Why bother defining these types? We make use of <a href="https://www.youtube.com/watch?v=kc9HwsxE1OY">multiple dispatch</a> to avoid calculating field terms that are unnecessary for special cases of emitter orientation.</p><h3 id="emitters_intro"><a class="docs-heading-anchor" href="#emitters_intro">Emitters</a><a id="emitters_intro-1"></a><a class="docs-heading-anchor-permalink" href="#emitters_intro" title="Permalink"></a></h3><p><code>Emitter</code>s emit radiofrequency energy in the waveguide. These are typically large, fixed VLF transmitters on the ground, but they could also be airborne. The type hierarchy in LongwaveModePropagator was designed with the thought that this could potentially be expanded to include natural emitters like lightning, although there is no internal functionality to directly handle such an emitter at this time.</p><p>All emitters subtype the abstract <a href="../../lib/internals/#LongwaveModePropagator.Emitter"><code>LongwaveModePropagator.Emitter</code></a> type.</p><p>The <a href="../../lib/public/#LongwaveModePropagator.Transmitter"><code>Transmitter</code></a> struct is used to define a typical man-made transmitter on the ground. A <code>Transmitter</code> has the fields</p><ul><li><code>name::String</code>: transmitter name.</li><li><code>latitude::Float64</code>: transmitter geographic latitude in degrees.</li><li><code>longitude::Float64</code>: transmitter geographic longitude in degrees.</li><li><code>antenna::Antenna</code>: transmitter antenna.</li><li><code>frequency::Frequency</code>: transmit frequency.</li><li><code>power::Float64</code>: transmit power in Watts.</li></ul><p>Note that currently <code>latitude</code> and <code>longitude</code> are not used. Distances are measured relative to the <code>Emitter</code> without reference to absolute positions.</p><p>Several convenience constructors exist to create <code>Transmitter</code>s with particular defaults for the remaining fields.</p><pre><code class="language-julia hljs">name = &quot;NAA&quot;
lat = 44.6464
lon = -67.2811
f = 24e3

tx = Transmitter(name, lat, lon, f)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Transmitter{VerticalDipole}(&quot;NAA&quot;, 44.6464, -67.2811, VerticalDipole(), Frequency(24000.0, 150796.44737231007, 0.0005030028052684036, 12491.352416666667), 1000.0)</code></pre><p>For the common case of transmitters on the ground with antennas modeled as a <code>VerticalDipole</code>, simply specify the transmit frequency.</p><pre><code class="language-julia hljs">tx = Transmitter(f)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Transmitter{VerticalDipole}(&quot;&quot;, 0.0, 0.0, VerticalDipole(), Frequency(24000.0, 150796.44737231007, 0.0005030028052684036, 12491.352416666667), 1000.0)</code></pre><p>Alternately an <code>Antenna</code>, frequency, and power level can be specified.</p><pre><code class="language-julia hljs">power = 500e3  # 500 kW
tx = Transmitter(hd, f, power)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Transmitter{HorizontalDipole}(&quot;&quot;, 0.0, 0.0, HorizontalDipole(0.7853981633974483), Frequency(24000.0, 150796.44737231007, 0.0005030028052684036, 12491.352416666667), 500000.0)</code></pre><p>Although not currently exported by LongwaveModePropagator, there is an <a href="../../lib/internals/#LongwaveModePropagator.AirborneTransmitter"><code>LongwaveModePropagator.AirborneTransmitter</code></a> defined that adds an <code>altitude</code> field to the basic <code>Transmitter</code> object. Further implementation and verification of the radiation resistance of an elevated antenna is required for accurate scaling of the electric field magnitude in the waveguide. In the meantime, if relative amplitude is sufficient, the height gain functions of an elevated transmitter are already incorporated into the model.</p><h3 id="samplers_intro"><a class="docs-heading-anchor" href="#samplers_intro">Samplers</a><a id="samplers_intro-1"></a><a class="docs-heading-anchor-permalink" href="#samplers_intro" title="Permalink"></a></h3><p>Structs that subtype <a href="../../lib/internals/#LongwaveModePropagator.AbstractSampler"><code>LongwaveModePropagator.AbstractSampler</code></a> probe the fields in the waveguide generated by an emitter. In common to all subtypes of <code>AbstractSampler</code> is that they have a position in the guide and specify what field component they sample.</p><p><code>Fields</code> is a <code>baremodule</code> contained within and reexported from LongwaveModePropagator.jl which contains a single enum object</p><pre><code class="language-julia hljs">Fields.Field</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Enum LongwaveModePropagator.Fields.Field:
Ex = 0
Ey = 1
Ez = 2</code></pre><p>Individual fields are specified with</p><pre><code class="language-julia hljs">field = Fields.Ez</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ez::Field = 2</code></pre><p>The general <a href="../../lib/public/#LongwaveModePropagator.Sampler"><code>Sampler</code></a> type specifies</p><ul><li><code>distance::T</code>: ground distance from the transmitter in meters.</li><li><code>fieldcomponent::Fields.Field</code>: field component measured by the <code>Sampler</code>.</li><li><code>altitude::Float64</code>: height above the ground in meters.</li></ul><p>The <code>distance</code> field is parameterized and therefore could be a single distance e.g. <code>2250e3</code>, a vector of distances <code>[2000e3, 2100e3, 2500e3]</code>, or a range <code>0:5e3:2000e3</code>, for example.</p><p>There is a special <a href="../../lib/public/#LongwaveModePropagator.GroundSampler"><code>GroundSampler</code></a> which lacks the <code>altitude</code> field in <code>Sampler</code>s because it is known from the type that <code>altitude = 0</code>.</p><pre><code class="language-julia hljs">distance = 2000e3
rx = GroundSampler(distance, field)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">GroundSampler{Float64}(2.0e6, LongwaveModePropagator.Fields.Ez)</code></pre><p>Finally there is a <code>Receiver</code> struct which is defined with a geographic location and <code>Antenna</code>, but it is not exported because geographic information is not currently handled by the package.</p><h2 id="waveguides_intro"><a class="docs-heading-anchor" href="#waveguides_intro">Waveguides</a><a id="waveguides_intro-1"></a><a class="docs-heading-anchor-permalink" href="#waveguides_intro" title="Permalink"></a></h2><p>The abstract <a href="../../lib/internals/#LongwaveModePropagator.Waveguide"><code>LongwaveModePropagator.Waveguide</code></a> type is used to describe the earth-ionosphere waveguide with a <a href="#bfield_intro"><code>BField</code></a>, <a href="#species_intro"><code>Species</code></a>, and <a href="#ground_intro"><code>Ground</code></a>.</p><p>The basic concrete waveguide type is a <a href="../../lib/public/#LongwaveModePropagator.HomogeneousWaveguide"><code>HomogeneousWaveguide</code></a>, with fields</p><ul><li><code>bfield::BField</code>: background magnetic field.</li><li><code>species::S</code>: ionosphere constituents.</li><li><code>ground::Ground</code>: waveguide ground.</li><li><code>distance::Float64</code>: distance from the <code>Emitter</code> at the start of the segment in meters.</li></ul><p>If not specified, <code>distance</code> is 0. The form of the function call is</p><p><code>HomogeneousWaveguide(bfield, species, ground)</code></p><p><code>HomogeneousWaveguide</code> should be used when modeling with only a single homogeneous waveguide (ground, ionosphere, and magnetic field) along the propagation path.</p><p>To model an inhomogeneous propagation path, there is a <a href="../../lib/public/#LongwaveModePropagator.SegmentedWaveguide"><code>SegmentedWaveguide</code></a> type. The <code>SegmentedWaveguide</code> is simply a wrapper for a <code>Vector</code> of waveguides.</p><p>Let&#39;s look at the components of a waveguide.</p><h3 id="bfield_intro"><a class="docs-heading-anchor" href="#bfield_intro">BField</a><a id="bfield_intro-1"></a><a class="docs-heading-anchor-permalink" href="#bfield_intro" title="Permalink"></a></h3><p>The <a href="../../lib/public/#LongwaveModePropagator.BField"><code>BField</code></a> type describes the magnitude and direction of the background magnetic field. Internally it consists of fields for the field strength <code>B</code> in Teslas and direction cosines corresponding to the directions parallel, perpendicular, and up into the waveguide.</p><p>A <code>BField</code> is most commonly constructed by specifying the field strength, <code>dip</code> angle in radians from the horizontal and positive when directed into Earth, and <code>azimuth</code> angle in radians from the propagation direction, positive towards <span>$y$</span>.</p><p>For example,</p><pre><code class="language-julia hljs">bfield = BField(50000e-9, π/2, 0)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">BField(5.0e-5, 6.123233995736766e-17, 0.0, -1.0)</code></pre><p><code>bfield</code> is a vertical magnetic field of 50,000 nT.</p><h3 id="species_intro"><a class="docs-heading-anchor" href="#species_intro">Species</a><a id="species_intro-1"></a><a class="docs-heading-anchor-permalink" href="#species_intro" title="Permalink"></a></h3><p>The <a href="../../lib/public/#LongwaveModePropagator.Species"><code>Species</code></a> struct identifies a constituent species of the ionosphere. <code>Species</code> contains the fields</p><ul><li><code>charge::Float64</code>: signed species charged in Coulombs.</li><li><code>mass::Float64</code>: species mass in kilograms.</li><li><code>numberdensity::F</code>: a callable that returns number density in number per cubic meter     as a function of height in meters.</li><li><code>collisionfrequency::G</code>: a callable that returns the collision frequency in     collisions per second as a function of height in meters.</li></ul><p><code>numberdensity</code> and <code>collisionfrequency</code> should be &quot;callables&quot; (usually <code>Function</code>s) that return the number density and collision frequency, respectively, as a function of height in meters.</p><p>For convenience, the Wait and Spies profile is accessible via <a href="../../lib/public/#LongwaveModePropagator.waitprofile"><code>waitprofile</code></a>. Similarly the accompanying collision frequency profiles are <a href="../../lib/public/#LongwaveModePropagator.electroncollisionfrequency"><code>electroncollisionfrequency</code></a> and <a href="../../lib/public/#LongwaveModePropagator.ioncollisionfrequency"><code>ioncollisionfrequency</code></a>.</p><p>To define some electrons for the ionosphere (<code>QE</code> and <code>ME</code> were explicitly imported at the top of the example):</p><pre><code class="language-julia hljs">h = 75
β = 0.35

electrons = Species(QE, ME, z-&gt;waitprofile(z, h, β), electroncollisionfrequency)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Species(-1.602176634e-19, 9.1093837015e-31, FunctionWrappers.FunctionWrapper{Float64, Tuple{Float64}}(Ptr{Nothing} @0x00007fc886981290, Ptr{Nothing} @0x00007fc8256c8070, Base.RefValue{Main.var&quot;#1#2&quot;}(Main.var&quot;#1#2&quot;()), Main.var&quot;#1#2&quot;), FunctionWrappers.FunctionWrapper{Float64, Tuple{Float64}}(Ptr{Nothing} @0x00007fc8869815e0, Ptr{Nothing} @0x00007fc8256c8078, Base.RefValue{typeof(electroncollisionfrequency)}(LongwaveModePropagator.electroncollisionfrequency), typeof(electroncollisionfrequency)))</code></pre><p>Note that we used a lambda function to specify the <code>waitprofile</code> with our given <span>$h&#39;$</span> and <span>$\beta$</span>. Also note that these two parameters are a rare instance of SI units not strictly being followed. See the help for <a href="../../lib/public/#LongwaveModePropagator.waitprofile"><code>waitprofile</code></a> for more information, including optional height cutoff and density threshold arguments.</p><p><code>electroncollisionfrequency</code> is a function of height <code>z</code> only, so it is not necessary to generate a lambda function. We can pass the function handle directly.</p><h3 id="ground_intro"><a class="docs-heading-anchor" href="#ground_intro">Ground</a><a id="ground_intro-1"></a><a class="docs-heading-anchor-permalink" href="#ground_intro" title="Permalink"></a></h3><p><a href="../ground/#Ground"><code>Ground</code></a> describes the relative permittivity <code>ϵᵣ</code> and conductivity <code>σ</code> of Earth.</p><pre><code class="language-julia hljs">ground = Ground(10, 2e-4)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ground(10, 0.0002)</code></pre><p>For convenience, a dictionary of common ground indices is exported.</p><pre><code class="language-julia hljs">GROUND</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Ground} with 10 entries:
  5  =&gt; Ground(15, 0.001)
  4  =&gt; Ground(10, 0.0003)
  6  =&gt; Ground(15, 0.003)
  7  =&gt; Ground(15, 0.01)
  2  =&gt; Ground(5, 3.0e-5)
  10 =&gt; Ground(81, 4.0)
  9  =&gt; Ground(15, 0.1)
  8  =&gt; Ground(15, 0.03)
  3  =&gt; Ground(10, 0.0001)
  1  =&gt; Ground(5, 1.0e-5)</code></pre><p><code>Dict</code>s aren&#39;t sorted, but simply specify the index as the key to access the <code>Ground</code> entry.</p><pre><code class="language-julia hljs">ground = GROUND[5]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Ground(15, 0.001)</code></pre><h2 id="Propagating-the-fields:-HomogeneousWaveguide"><a class="docs-heading-anchor" href="#Propagating-the-fields:-HomogeneousWaveguide">Propagating the fields: HomogeneousWaveguide</a><a id="Propagating-the-fields:-HomogeneousWaveguide-1"></a><a class="docs-heading-anchor-permalink" href="#Propagating-the-fields:-HomogeneousWaveguide" title="Permalink"></a></h2><p>We&#39;ll redefine everything we&#39;ve defined above just so they&#39;re easier to see, run the model, and plot the results.</p><pre><code class="language-julia hljs">f = 24e3
tx = Transmitter(f)

ranges = 0:5e3:2000e3
field = Fields.Ez
rx = GroundSampler(ranges, field)

bfield = BField(50e-6, π/2, 0)
electrons = Species(QE, ME, z-&gt;waitprofile(z, 75, 0.35), electroncollisionfrequency)
ground = GROUND[5]

waveguide = HomogeneousWaveguide(bfield, electrons, ground)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">HomogeneousWaveguide{Species}(BField(5.0e-5, 6.123233995736766e-17, 0.0, -1.0), Species(-1.602176634e-19, 9.1093837015e-31, FunctionWrappers.FunctionWrapper{Float64, Tuple{Float64}}(Ptr{Nothing} @0x00007fc886987420, Ptr{Nothing} @0x00007fc8256c8068, Base.RefValue{Main.var&quot;#3#4&quot;}(Main.var&quot;#3#4&quot;()), Main.var&quot;#3#4&quot;), FunctionWrappers.FunctionWrapper{Float64, Tuple{Float64}}(Ptr{Nothing} @0x00007fc8869815e0, Ptr{Nothing} @0x00007fc8256c8080, Base.RefValue{typeof(electroncollisionfrequency)}(LongwaveModePropagator.electroncollisionfrequency), typeof(electroncollisionfrequency))), Ground(15, 0.001), 0.0)</code></pre><p>The <a href="../../lib/public/#LongwaveModePropagator.propagate"><code>propagate</code></a> function returns a tuple of complex electric field, amplitude in dB μV/m, and phase in radians.</p><pre><code class="language-julia hljs">E, a, p = propagate(waveguide, tx, rx);</code></pre><p>Here are quick plots of the amplitude</p><pre><code class="language-julia hljs">plot(ranges/1000, a;
     xlabel=&quot;range (km)&quot;, ylabel=&quot;amplitude (dB)&quot;,
     linewidth=1.5, legend=false)</code></pre><p><img src="../basic_homogeneousamplitude.png" alt/></p><p>and phase.</p><pre><code class="language-julia hljs">plot(ranges/1000, rad2deg.(p);
     xlabel=&quot;range (km)&quot;, ylabel=&quot;phase (deg)&quot;,
     linewidth=1.5, legend=false)</code></pre><p><img src="../basic_homogeneousphase.png" alt/></p><h2 id="Propagating-the-fields:-SegmentedWaveguide"><a class="docs-heading-anchor" href="#Propagating-the-fields:-SegmentedWaveguide">Propagating the fields: SegmentedWaveguide</a><a id="Propagating-the-fields:-SegmentedWaveguide-1"></a><a class="docs-heading-anchor-permalink" href="#Propagating-the-fields:-SegmentedWaveguide" title="Permalink"></a></h2><p>As previously mentioned, a <a href="../../lib/public/#LongwaveModePropagator.SegmentedWaveguide"><code>SegmentedWaveguide</code></a> contains a vector of <a href="../../lib/public/#LongwaveModePropagator.HomogeneousWaveguide"><code>HomogeneousWaveguide</code></a>s. There are many ways to construct a <code>SegmentedWaveguide</code>.</p><p>One common case is when a vector of <code>BField</code>s, <code>Species</code>, and/or <code>Ground</code>s are known for each <code>HomogeneousWaveguide</code> making up the <code>SegmentedWaveguide</code>. We&#39;ll also need to specify the distance at which each waveguide segment begins relative to the transmitter.</p><p>The first <code>HomogeneousWaveguide</code> should have a distance of 0. An error will eventually be thrown if that is not the case.</p><p>In this example we&#39;ll have two segments. The second segment begins 1000 km away from the transmitter.</p><pre><code class="language-julia hljs">distances = [0.0, 1000e3]
species = [Species(QE, ME, z-&gt;waitprofile(z, 75, 0.35), electroncollisionfrequency),
           Species(QE, ME, z-&gt;waitprofile(z, 82, 0.5), electroncollisionfrequency)]

waveguide = SegmentedWaveguide([HomogeneousWaveguide(bfield, species[i], ground,
                                                     distances[i]) for i in 1:2]);</code></pre><p>We can <a href="../../lib/public/#LongwaveModePropagator.propagate"><code>propagate</code></a> just as before</p><pre><code class="language-julia hljs">E, a, p = propagate(waveguide, tx, rx);</code></pre><p>Here are quick plots of the amplitude</p><pre><code class="language-julia hljs">plot(ranges/1000, a;
     xlabel=&quot;range (km)&quot;, ylabel=&quot;amplitude (dB)&quot;,
     linewidth=1.5, legend=false)</code></pre><p><img src="../basic_segmentedamplitude.png" alt/></p><p>and phase.</p><pre><code class="language-julia hljs">plot(ranges/1000, rad2deg.(p);
     xlabel=&quot;range (km)&quot;, ylabel=&quot;phase (deg)&quot;,
     linewidth=1.5, legend=false)</code></pre><p><img src="../basic_segmentedphase.png" alt/></p><p>Comparing to the plots for the <code>HomogeneousWaveguide</code> above, the results are the same for the first 1000 km and differ for the second 1000 km where there is a different ionosphere in the <code>SegmentedWaveguide</code> scenario.</p><h2 id="LMPParams"><a class="docs-heading-anchor" href="#LMPParams"><code>LMPParams</code></a><a id="LMPParams-1"></a><a class="docs-heading-anchor-permalink" href="#LMPParams" title="Permalink"></a></h2><p>Many functions within the LongwaveModePropagator package take an optional <code>params</code> argument <a href="#LMPParams"><code>LMPParams</code></a>. <code>LMPParams</code> is a keyword-compatible <code>struct</code> defined with the <code>@with_kw</code> argument from the <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> package. An instance of <code>LMPParams</code> contains model parameters and switches used throughout the package.</p><p>The default values are obtained by invoking</p><pre><code class="language-julia hljs">LMPParams()</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LMPParams{OrdinaryDiffEq.Vern7{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}
  topheight: Float64 110000.0
  earthradius: Float64 6.369e6
  earthcurvature: Bool true
  curvatureheight: Float64 50000.0
  approxsusceptibility: Bool false
  susceptibilitysplinestep: Float64 10.0
  grpfparams: GRPFParams
  integrationparams: IntegrationParams{OrdinaryDiffEq.Vern7{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}}
  wavefieldheights: StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
  wavefieldintegrationparams: IntegrationParams{OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}}
  radiationresistancecorrection: Bool false
</code></pre><p>A single value can be specified as a keyword argument while keeping all other values as their defaults</p><pre><code class="language-julia hljs">LMPParams(approxsusceptibility=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">LMPParams{OrdinaryDiffEq.Vern7{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}
  topheight: Float64 110000.0
  earthradius: Float64 6.369e6
  earthcurvature: Bool true
  curvatureheight: Float64 50000.0
  approxsusceptibility: Bool true
  susceptibilitysplinestep: Float64 10.0
  grpfparams: GRPFParams
  integrationparams: IntegrationParams{OrdinaryDiffEq.Vern7{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}}
  wavefieldheights: StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}
  wavefieldintegrationparams: IntegrationParams{OrdinaryDiffEq.Tsit5{typeof(OrdinaryDiffEq.trivial_limiter!), typeof(OrdinaryDiffEq.trivial_limiter!), Static.False}}
  radiationresistancecorrection: Bool false
</code></pre><p>An instance of <code>LMPParams</code> can be passed as the <code>params</code> argument of <a href="../../lib/public/#LongwaveModePropagator.propagate"><code>propagate</code></a> or <a href="../../lib/public/#LongwaveModePropagator.findmodes"><code>findmodes</code></a>.</p><p>See the <a href="https://github.com/mauro3/Parameters.jl">Parameters.jl</a> README for other ways of interacting with <a href="#LMPParams"><code>LMPParams</code></a>.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../io/">File-based I/O »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.3.0 on <span class="colophon-date" title="Friday 22 March 2024 00:31">Friday 22 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
